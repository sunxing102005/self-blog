/*
 Navicat Premium Data Transfer

 Source Server         : 47.97.161.236_3306
 Source Server Type    : MySQL
 Source Server Version : 50725
 Source Host           : 47.97.161.236:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50725
 File Encoding         : 65001

 Date: 06/06/2019 20:21:04
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for sx_comment
-- ----------------------------
DROP TABLE IF EXISTS `sx_comment`;
CREATE TABLE `sx_comment` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `content_id` int(10) DEFAULT NULL,
  `author` varchar(200) DEFAULT NULL,
  `email` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(500) DEFAULT NULL,
  `text` text,
  `status` int(10) DEFAULT NULL,
  `parent_id` int(10) DEFAULT '0',
  `create_time` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for sx_config
-- ----------------------------
DROP TABLE IF EXISTS `sx_config`;
CREATE TABLE `sx_config` (
  `id` int(100) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `value` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sx_config
-- ----------------------------
BEGIN;
INSERT INTO `sx_config` VALUES (1, 'site', '{\"title\":\"xin\",\"url\":\"\",\"keywords\":\"333\",\"description\":\"333\"}');
INSERT INTO `sx_config` VALUES (2, 'email', '{\"secure\":1,\"user\":\"\",\"pass\":\"\",\"port\":\"465\",\"host\":\"qq\"}');
COMMIT;

-- ----------------------------
-- Table structure for sx_content
-- ----------------------------
DROP TABLE IF EXISTS `sx_content`;
CREATE TABLE `sx_content` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `title` varchar(200) NOT NULL,
  `user_id` int(10) NOT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `thumb` varchar(200) DEFAULT NULL,
  `category_id` int(10) NOT NULL,
  `status` int(1) NOT NULL DEFAULT '1',
  `type` varchar(20) NOT NULL,
  `description` text,
  `markdown` text,
  `content` text,
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  `view` int(10) NOT NULL DEFAULT '0',
  `publish_time` datetime DEFAULT NULL,
  `recommend` varchar(255) DEFAULT NULL,
  `like` int(200) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sx_content
-- ----------------------------
BEGIN;
INSERT INTO `sx_content` VALUES (1, '浅谈 js 变量作用域', 1, 'js-variables', '/uploads/2019/05/6b1e340b9a786d9000143690fe185e70.jpg', 1, 99, 'post', '<p>关于 javascript 这门语言许多人都是从开始的时候觉得容易，后来觉得难，再后来又觉得容易的过程走过来的。最开始的时候觉得简单，是因为没有重视，没有把它当作一门语言来来认真对待，总是以自己学习其他语言的“经验”来使用它。在使用中会遇到各种问题，比如 javascript特有的变量作用域和异步问题，这时候会觉得它其实也很难。但是如果真正理解了变量作用域和异步，其实也不是很难。只是写法的区别。</p>', '关于 javascript 这门语言许多人都是从开始的时候觉得容易，后来觉得难，再后来又觉得容易的过程走过来的。最开始的时候觉得简单，是因为没有重视，没有把它当作一门语言来来认真对待，总是以自己学习其他语言的“经验”来使用它。在使用中会遇到各种问题，比如 javascript特有的变量作用域和异步问题，这时候会觉得它其实也很难。但是如果真正理解了变量作用域和异步，其实也不是很难。只是写法的区别。\n<!--more-->\n无意间看到一套前端面试题，作为后端汪，也只能看看其中的 js 部分，见到一道 js 笔试题特别不错，特尝试解答一下。\n\n原题：\n```javascript\n\n    var a, b = 0, fn = function(){\n            var a = b = 2;\n        };\n        fn();\n        console.log(a, b);\n```\n\n看上去很简单的一道题，细细分析一下却发现这题出的真妙。咱们一行一行分析\n\n第一行声明了a,b,fn，此时a声明但未赋值，故a=undefined,b=0,fn为一个函数。\n\n第四行执行fn函数。\n\n在fn函数内部 var a=b=2;    这里才是真正的重点，var a重新使用 var 对 a做了覆盖声明，并把 b 的值赋给它。后面 b =2。这里 b 并没有使用 var 声明。事实上这一行是创建了一个函数内部的变量 a，和对全局变量 b 进行赋值。所以虽然这里 a 也被赋值了，但此时它是个函数内部的变量，外部无法访问。\n\n第五行，输出全局变量a和b，所以此时a=undefined，b=2；\n\n我们再来转换一种写法。\n```javascript\nvar a, b = 0, fn = function(){\n		var b=1;\n        a = b = 2;\n        console.log(a, b);\n    };\n    fn();\n    console.log(a, b);\n```\n\n和上面一样，第一行对三个变量声明。\n\n此时第四行输出a和b时都是函数内部的变量，a和b都是2\n\n最后一行输出的时候全局变量a是，在函数内部被赋值，所以是2。全局变量b在第一行被复制0，但是在函数内部第三行被var 重新声明为函数内部的变量，虽然被赋值为1，虽然下一行被赋值为2，但是事实上和全部变量b是没有关系的。所以此时b为0', '<p>关于 javascript 这门语言许多人都是从开始的时候觉得容易，后来觉得难，再后来又觉得容易的过程走过来的。最开始的时候觉得简单，是因为没有重视，没有把它当作一门语言来来认真对待，总是以自己学习其他语言的“经验”来使用它。在使用中会遇到各种问题，比如 javascript特有的变量作用域和异步问题，这时候会觉得它其实也很难。但是如果真正理解了变量作用域和异步，其实也不是很难。只是写法的区别。</p><!--more-->\n<p>无意间看到一套前端面试题，作为后端汪，也只能看看其中的 js 部分，见到一道 js 笔试题特别不错，特尝试解答一下。</p><p>原题：</p><pre><code class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> a, b = <span class=\"hljs-number\">0</span>, fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n            <span class=\"hljs-keyword\">var</span> a = b = <span class=\"hljs-number\">2</span>;\n        };\n        fn();\n        <span class=\"hljs-built_in\">console</span>.log(a, b);</code></pre>\n<p>看上去很简单的一道题，细细分析一下却发现这题出的真妙。咱们一行一行分析</p><p>第一行声明了a,b,fn，此时a声明但未赋值，故a=undefined,b=0,fn为一个函数。</p><p>第四行执行fn函数。</p><p>在fn函数内部 var a=b=2;    这里才是真正的重点，var a重新使用 var 对 a做了覆盖声明，并把 b 的值赋给它。后面 b =2。这里 b 并没有使用 var 声明。事实上这一行是创建了一个函数内部的变量 a，和对全局变量 b 进行赋值。所以虽然这里 a 也被赋值了，但此时它是个函数内部的变量，外部无法访问。</p><p>第五行，输出全局变量a和b，所以此时a=undefined，b=2；</p><p>我们再来转换一种写法。</p><pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> a, b = <span class=\"hljs-number\">0</span>, fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">var</span> b=<span class=\"hljs-number\">1</span>;\n        a = b = <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-built_in\">console</span>.log(a, b);\n    };\n    fn();\n    <span class=\"hljs-built_in\">console</span>.log(a, b);</code></pre>\n<p>和上面一样，第一行对三个变量声明。</p><p>此时第四行输出a和b时都是函数内部的变量，a和b都是2</p><p>最后一行输出的时候全局变量a是，在函数内部被赋值，所以是2。全局变量b在第一行被复制0，但是在函数内部第三行被var 重新声明为函数内部的变量，虽然被赋值为1，虽然下一行被赋值为2，但是事实上和全部变量b是没有关系的。所以此时b为0</p>', '2019-04-04 11:49:32', '2019-05-27 12:02:33', 0, '2019-05-27 12:02:33', 'Y', NULL);
INSERT INTO `sx_content` VALUES (7, '插件机制的实现与原理', 1, 'plug', '/uploads/2019/05/6054dc4984cedbd296f525cf25bb14a7.jpg', 2, 0, 'post', '<p>如果使用过 wordpress、discuz等开源程序的同学可能对插件不太陌生。下载一个插件，放进指定的文件夹，直接就可以使用。让程序有了极其强大的扩展性。</p>', '\n如果使用过 wordpress、discuz等开源程序的同学可能对插件不太陌生。下载一个插件，放进指定的文件夹，直接就可以使用。让程序有了极其强大的扩展性。\n<!--more-->\n在这之前我们可能要了解一下 观察者模式 的原理，在这里我们需要一个观察者，把程序当成被观察的对象。当程序运行到一些程序允许使用插件的地方，则观察者向符合程序要求的插件发送通知。我把这个允许使用插件的地方叫做“钩子”。\n\n首先我们编写程序的时候要注意，在需要后期进行扩展开发，或者修改的地方，我们应当留下这个“钩子”。比如用户登录，发帖，充值等地方。\n```php\n$this->register_use(\'LOGIN_SUCCESS\',$data);\n```\n然后在“钩子”函数中通知插件：此时程序运行到了 LOGIN_SUCCESS 这个地方。\n```php\nfunction register_use($behavior,$data){\n            $handle=opendir(APP_FILE.\'use/\');\n            while($file=readdir($handle)) {\n                if (($file!=\".\")&&($file!=\"..\")&&strstr($file,\'.class.php\')){\n                    $classname=str_replace(\'.class.php\',\'\',$file);\n                    $obj = new ReflectionClass($classname);\n                    if($obj->hasMethod(\'notify\')){\n                        $instance =$obj->newInstanceArgs();\n                        $obj->getmethod(\'notify\')->invoke($instance,array(\'behavior\'=>$behavior,\'data\'=>$data));\n                    }\n                }\n            }\n            closedir($handle);\n        }\n```\n这里我们遍历了插件所在目录，并把符合我们要求的类挑选出来发送通知，因为使用了自动加载，所以没有引入文件这个操作，如果没有使用自动加载需要引入对应的文件。\n\n然后在插件的父类中添加一个通知方法\n```php\nfunction notify($data){\n            $behavior=\'use_\'.strtolower($data[\'behavior\']);\n            if(method_exists($this,$behavior)==true){\n                $this->$behavior($data[\'data\']);\n            }\n        }\n```\n这样，我们就可以在插件目录下编写文件，只要继承父类或者自己编写一个通知方法，即可接收到程序运行时发出的通知。编写对应的代码即可在执行到钩子的时候运行。\n```php\nfunction use_login_success(){\n			echo \"use_login_success\";\n			die();\n		}\n```\n然后我们登录测试一下\n![EVrMRrb.png!web.png][1]\n这时候我们发现，在登录处理完后触发了插件的方法。这时候，一个简单的插件就完成了。\n\n\n  [1]: http://lscho.com/usr/uploads/2017/03/4119552257.png', '<p>如果使用过 wordpress、discuz等开源程序的同学可能对插件不太陌生。下载一个插件，放进指定的文件夹，直接就可以使用。让程序有了极其强大的扩展性。</p><!--more-->\n<p>在这之前我们可能要了解一下 观察者模式 的原理，在这里我们需要一个观察者，把程序当成被观察的对象。当程序运行到一些程序允许使用插件的地方，则观察者向符合程序要求的插件发送通知。我把这个允许使用插件的地方叫做“钩子”。</p><p>首先我们编写程序的时候要注意，在需要后期进行扩展开发，或者修改的地方，我们应当留下这个“钩子”。比如用户登录，发帖，充值等地方。</p><pre><code class=\"language-php\">$<span class=\"hljs-keyword\">this</span>-&gt;register_use(<span class=\"hljs-string\">\'LOGIN_SUCCESS\'</span>,$data);</code></pre>\n<p>然后在“钩子”函数中通知插件：此时程序运行到了 LOGIN_SUCCESS 这个地方。</p><pre><code class=\"language-php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">register_use</span>(<span class=\"hljs-params\">$behavior,$data</span>)</span>{\n            $handle=opendir(APP_FILE.<span class=\"hljs-string\">\'use/\'</span>);\n            <span class=\"hljs-keyword\">while</span>($file=readdir($handle)) {\n                <span class=\"hljs-keyword\">if</span> (($file!=<span class=\"hljs-string\">\".\"</span>)&amp;&amp;($file!=<span class=\"hljs-string\">\"..\"</span>)&amp;&amp;strstr($file,<span class=\"hljs-string\">\'.class.php\'</span>)){\n                    $classname=str_replace(<span class=\"hljs-string\">\'.class.php\'</span>,<span class=\"hljs-string\">\'\'</span>,$file);\n                    $obj = <span class=\"hljs-keyword\">new</span> ReflectionClass($classname);\n                    <span class=\"hljs-keyword\">if</span>($obj-&gt;hasMethod(<span class=\"hljs-string\">\'notify\'</span>)){\n                        $instance =$obj-&gt;newInstanceArgs();\n                        $obj-&gt;getmethod(<span class=\"hljs-string\">\'notify\'</span>)-&gt;invoke($instance,array(<span class=\"hljs-string\">\'behavior\'</span>=&gt;$behavior,<span class=\"hljs-string\">\'data\'</span>=&gt;$data));\n                    }\n                }\n            }\n            closedir($handle);\n        }</code></pre>\n<p>这里我们遍历了插件所在目录，并把符合我们要求的类挑选出来发送通知，因为使用了自动加载，所以没有引入文件这个操作，如果没有使用自动加载需要引入对应的文件。</p><p>然后在插件的父类中添加一个通知方法</p><pre><code class=\"language-php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">notify</span>(<span class=\"hljs-params\">$data</span>)</span>{\n            $behavior=<span class=\"hljs-string\">\'use_\'</span>.strtolower($data[<span class=\"hljs-string\">\'behavior\'</span>]);\n            <span class=\"hljs-keyword\">if</span>(method_exists($<span class=\"hljs-keyword\">this</span>,$behavior)==<span class=\"hljs-literal\">true</span>){\n                $<span class=\"hljs-keyword\">this</span>-&gt;$behavior($data[<span class=\"hljs-string\">\'data\'</span>]);\n            }\n        }</code></pre>\n<p>这样，我们就可以在插件目录下编写文件，只要继承父类或者自己编写一个通知方法，即可接收到程序运行时发出的通知。编写对应的代码即可在执行到钩子的时候运行。</p><pre><code class=\"language-php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">use_login_success</span>(<span class=\"hljs-params\"></span>)</span>{\n            echo <span class=\"hljs-string\">\"use_login_success\"</span>;\n            die();\n        }</code></pre>\n<p>然后我们登录测试一下\n<img src=\"http://lscho.com/usr/uploads/2017/03/4119552257.png\" alt=\"EVrMRrb.png!web.png\">\n这时候我们发现，在登录处理完后触发了插件的方法。这时候，一个简单的插件就完成了。</p>', '2019-05-14 11:49:39', '2019-05-27 12:01:49', 0, '2019-05-27 12:01:49', 'Y', NULL);
INSERT INTO `sx_content` VALUES (9, 'About', 1, 'about', NULL, 0, 99, 'page', '', '\n历程\n\n已经忘记了换了多少个域名。\n\n每换一次数据就丢一点。\n\n用以前的域名搜索了一下，恢复了一点文章。\n\n三天打鱼两天晒网。\n\n得治!\n\n从 2014 年开始写博客，也不能算是写博客，就是换服务器，换程序的一个折腾的过程。\n\n写过一个 php 的博客程序\n\n写过一个 nodejs的博客\n\n但是最终都是因为域名没有续费或是服务器没有续费最后弃用。连数据都没有保存。\n\n这次换了域名，换了服务器全部都是续了三年的费用，就这样。不折腾了。\n说明\n\n域名是我的名字拼音中取出来的几个字母。xin 则是我尚未见面的前世小情人的名字，以后这个博客会陪着她长大。\n环境和优化\n\n腾讯云、centos、lnmp、nodejs、redis、https、http2等\n', '<p>历程</p>\n<p>已经忘记了换了多少个域名。</p>\n<p>每换一次数据就丢一点。</p>\n<p>用以前的域名搜索了一下，恢复了一点文章。</p>\n<p>三天打鱼两天晒网。</p>\n<p>得治!</p>\n<p>从 2014 年开始写博客，也不能算是写博客，就是换服务器，换程序的一个折腾的过程。</p>\n<p>写过一个 php 的博客程序</p>\n<p>写过一个 nodejs的博客</p>\n<p>但是最终都是因为域名没有续费或是服务器没有续费最后弃用。连数据都没有保存。</p>\n<p>这次换了域名，换了服务器全部都是续了三年的费用，就这样。不折腾了。<br />\n说明</p>\n<p>域名是我的名字拼音中取出来的几个字母。xin 则是我尚未见面的前世小情人的名字，以后这个博客会陪着她长大。<br />\n环境和优化</p>\n<p>腾讯云、centos、lnmp、nodejs、redis、https、http2等</p>\n', '2019-05-06 11:49:44', NULL, 61, NULL, 'Y', NULL);
INSERT INTO `sx_content` VALUES (10, 'Links', 1, 'links', NULL, 0, 99, 'page', '', '## 链接\n\n<ul class=\"flinks\">\n<li><a href=\"https://imququ.com/\">Jerry Qu</a></li>\n<li><a href=\"https://xuexb.com/\">谢亮</a></li>\n<li><a href=\"http://sentsin.com/\">贤心</a></li>\n<li><a href=\"http://www.barretlee.com/entry/\">小胡子哥</a></li>\n<li><a href=\"http://www.laruence.com/\">鸟哥</a></li>\n<li><a href=\"https://github.com/rccoder/blog/issues\">rccoder</a></li>\n<li><a href=\"https://cnodejs.org/\">CNode社区</a></li>\n<li><a href=\"https://laravel-china.org/topics\">laravel社区</a></li>\n<li><a href=\"https://juejin.im/explore/all\">掘金</a></li>\n<li><a href=\"https://segmentfault.com/\">segmentfault</a></li>\n<li><a href=\"https://joyqi.com/\">joyqi</a></li>\n</ul>\n\n## 说明\n\n> 以上为经常关注的博客和社区，不定期更新。', '<h2>链接</h2>\n<ul class=\"flinks\">\n<li><a href=\"https://imququ.com/\">Jerry Qu</a></li>\n<li><a href=\"https://xuexb.com/\">谢亮</a></li>\n<li><a href=\"http://sentsin.com/\">贤心</a></li>\n<li><a href=\"http://www.barretlee.com/entry/\">小胡子哥</a></li>\n<li><a href=\"http://www.laruence.com/\">鸟哥</a></li>\n<li><a href=\"https://github.com/rccoder/blog/issues\">rccoder</a></li>\n<li><a href=\"https://cnodejs.org/\">CNode社区</a></li>\n<li><a href=\"https://laravel-china.org/topics\">laravel社区</a></li>\n<li><a href=\"https://juejin.im/explore/all\">掘金</a></li>\n<li><a href=\"https://segmentfault.com/\">segmentfault</a></li>\n<li><a href=\"https://joyqi.com/\">joyqi</a></li>\n</ul>\n<h2>说明</h2>\n<blockquote>\n<p>以上为经常关注的博客和社区，不定期更新。</p>\n</blockquote>\n', '2019-04-19 11:49:49', NULL, 33, NULL, 'Y', NULL);
INSERT INTO `sx_content` VALUES (30, 'JointJS处理两条线的交点', 1, '1c9f9f59440f5c0f0ed61fdf56779de7', '/uploads/2019/05/26cbd7482a74c5615527c2bc556eb9fe.jpg', 1, 99, 'post', '<pre><code>使用jointJs绘制流程图时，如果两条连线相交，这两条线不会像Viso一样，对交点进行处理（交点处有弧线）。虽然鼠标选中连线时，单条线会有自动点亮的效果，但是在客户强烈要求下（！！！），我还是做了保存时对两条线交点的处理。</code></pre>', '\n\n    使用jointJs绘制流程图时，如果两条连线相交，这两条线不会像Viso一样，对交点进行处理（交点处有弧线）。虽然鼠标选中连线时，单条线会有自动点亮的效果，但是在客户强烈要求下（！！！），我还是做了保存时对两条线交点的处理。\n<!--more-->\n一.问题概述\n    本处理方法生效有几个前提\n\n    1.本方法实质是在保存时，把连线的属性vertices(即保存折点信息的属性)改变,并存到数据库。所以只适用于保存时，并非在两条线相交时实时触发。\n\n    2.本方法不适用于大于两条线交于一点。\n\n    3.本方法不适用于n条直线相交，产生n个交点（n>2）。其实这个是可以实现的，只是客户没有这个需求，我也懒得写。\n\n    4.交点处会折成三角形凸起，而不是Viso一样的弧（能力有限）,如下图所示。\n​​​​​![joint01.jpg](/uploads/2019/02/c0ec89292bb71333a2c718ce49fd7134.jpg)\n    5.两条线相交后，如果改变线的位置，保存时两线交点位置不会随着两线的位置改变。因为无法区分vertices里面的折点是人为折的还是自动计算生成的交线折点。需要删掉折叠的线，再连接一次，再保存。（应该也可以做，但是客户没要求）\n二.解决方法整体思路 \n\n      因为jointJs并没有对于两条线相交的监听事件，也没有得到graph上所有交点的方法，所以只能通过计算得到两条线的交点坐标。\n\n    首先需要得到每条线的起点，终点，以及该线的折点(vertices)。将每条线当做一个数组，存储着一个个线段。具体来说，比如线A有一个折点，起点到折点1算是一个线段，折点一到终点是一个线段，所以线A的数组有两个线段元素。\n\n    先用双重循环使得每两条线相遇一次（取出两条线，并且这两条线的组合不重复）。取出相遇的两条线，线A与线B。再通过两重循环，将线A的每条线段，与线B的每条线段相遇（同样不重复）。这样我们得到了分别来自两条线的两条线段，也得到了两条线段的起点，终点 共四个点坐标值。通过计算，得到两条线段的交点坐标。\n\n    如果想让线A折叠，则通过线B的折线斜率计算得到中间折点两侧的两个折点的坐标值。通过线A的斜率得到交点上方，中心折点的坐标，使得中间折点在线A上。得到三个折点后，保存到连线（link）的vertices属性里，刷新后交点就出现了。\n\n三.代码部分\n\n    1.前端：\n\n        前端代码的难点在于得到连线的准确起点坐标与终点坐标。因为graph.getLinks()方法只是得到link的model，而model里面只有sourceId,targetId 也就是连线的起点图形和终点图形的图形id。图形坐标肯定不是连线起点或者终点的准确坐标。在查找JointJs API后，发现link 的view里面存着sourcePoint,targetPoint 属性，分别存着起始点的坐标值。于是代码中，首先通过link 的model得到view，再将view里面的起终点坐标值传到后台。\n\n    代码如下：\n```javascript\nfunction saveLC (){\n        	if(TREENODE==null||TREENODE.type!=5){\n				app.graph.fromJSON(JSON.parse(\"{\\\"cells\\\":[]} \"));\n				layer.alert(\"当前树节点无法保存流程信息！\");\n			return\n			}\n        	var t = app.graph.getCellsBBox();\n        	var xxx= app.graph.getLinks();\n        	var mapA = {};\n        	 for(var i=0;i<xxx.length;i++){\n        		var mapT = {}; \n        		var u=xxx[i];\n        		var vv=u.findView(app.paper);//通过model得到view \n        		//通过view得到link的起点终点坐标\n        		var tsX=vv.sourcePoint.x;\n        		var tsY=vv.sourcePoint.y;\n        		var ttX=vv.targetPoint.x;\n        		var ttY=vv.targetPoint.y;\n        		mapT[\"tsX\"] = tsX;\n        		mapT[\"tsY\"] = tsY;\n        		mapT[\"ttX\"] = ttX;\n        		mapT[\"ttY\"] = ttY;\n        		mapA[u.id] = mapT;\n        	} \n        	 var lv = JSON.stringify(mapA);\n			$.ajax({type:\"POST\",url:\"saveLC.do\",\n				data :{lcid:TREENODE.id,\'elements\':JSON.stringify(app.graph.getElements()),\n						 \'links\':JSON.stringify(app.graph.getLinks()),\'linksView\':lv},\n				dataType:\"text\",success:function(data) {\n					if(\"false\"!=data){				\n					layer.msg(\"保存成功!\");\n					refreshPaper();\n					ifChange =false;\n					$(\"#btn-edit-page\").html(\"修改\");\n					}else{\n						layer.msg(\"保存失败!该流程不存在或已删除!\");\n					}\n				}\n			});\n		}\n```\n2.后端\n\n后端具体思路上文已经交代，代码上把判断两线段交点的方法，单独抽出来作为一个方法，同时抽出来判断交点在不在线段起终点之间的方法，便于判断交点是否可取。主要代码我写在了service里，具体代码如下：\n```javaScript\n   \n    \n\npublic Map<String,Object> handleJunction(JSONArray link,JSONObject linkView){\n		Map<String,Object> map = new HashMap<String, Object>();\n		for(int i=0;i<link.size()-1;i++){\n			for(int j=i+1;j<link.size();j++){\n				//所有的线，两两碰面，计算线中折线段是否相交\n				JSONObject objA = link.getJSONObject(i);//线A\n				JSONObject objB = link.getJSONObject(j);//线B\n				String ifACross = objA.getString(\"ifCross\");\n				String ifBCross = objB.getString(\"ifCross\");\n				if(!\"no\".equals(ifACross)&&!\"no\".equals(ifBCross)){\n					//已经相交的线，不再判断了\n					continue;\n				}\n				String idA = objA.getString(\"id\");//线A 的id \n				JSONObject viewA = linkView.getJSONObject(idA);//线A的起点，终点坐标信息\n				\n				String idB = objB.getString(\"id\");//线B 的id \n				JSONObject viewB = linkView.getJSONObject(idB);//线B的起点，终点坐标信息\n				JSONArray vtA = objA.getJSONArray(\"vertices\");//线A vetices 的json数组信息\n				JSONArray vtB = objB.getJSONArray(\"vertices\");//线B vetices 的json数组信息\n				List<Map<String,Object>> juncInfo = new ArrayList<Map<String,Object>>();//取得的交点信息放到list里面\n//				if(vtA.size()>0){\n					Integer startAX = -1;//初始化线A 折线段的起点x轴坐标\n					Integer startAY = -1;//折线段的起点y轴坐标\n					Integer endAX = -1;//初始化线A 折线段的终点x轴坐标\n					Integer endAY = -1;//初始化线A 折线段的终点y轴坐标\n					for(int k=0;k<vtA.size()+1;k++){\n						//循环vertices信息，即折线拐点信息\n						if(vtA.size() == 0){\n							//当没有拐点时，折线的起点终点，就是线A的起点终点\n							startAX = viewA.getInt(\"tsX\");\n							startAY = viewA.getInt(\"tsY\");\n							endAX = viewA.getInt(\"ttX\");\n							endAY = viewA.getInt(\"ttY\");\n						}else if(k==0){\n							//有拐点时，第一次循环，折线起点是线A起点，折线终点是第一个拐点\n							startAX = viewA.getInt(\"tsX\");\n							startAY = viewA.getInt(\"tsY\");\n							endAX = vtA.getJSONObject(0).getInt(\"x\");\n							endAY = vtA.getJSONObject(0).getInt(\"y\");\n						}else if(k==vtA.size()){\n							//最后一次循环，折线起点是最后一个拐点，折线终点是线A的终点\n							startAX = vtA.getJSONObject(k-1).getInt(\"x\");\n							startAY = vtA.getJSONObject(k-1).getInt(\"y\");\n							endAX = viewA.getInt(\"ttX\");\n							endAY = viewA.getInt(\"ttY\");\n						}else{\n							//其它情况，起点是第k-1个拐点，终点是第k个拐点\n							startAX = vtA.getJSONObject(k-1).getInt(\"x\");\n							startAY = vtA.getJSONObject(k-1).getInt(\"y\");\n							endAX = vtA.getJSONObject(k).getInt(\"x\");\n							endAY = vtA.getJSONObject(k).getInt(\"y\");\n						}\n						//初始化线B的折线起，终点\n						Integer startBX = -1;\n						Integer startBY = -1;\n						Integer endBX = -1;\n						Integer endBY = -1;\n						\n							for(int m=0;m<vtB.size()+1;m++){\n								//同理线A,得到折线的起点，终点\n								if(vtB.size()==0){\n									startBX = viewB.getInt(\"tsX\");\n									startBY = viewB.getInt(\"tsY\");\n									endBX = viewB.getInt(\"ttX\");\n									endBY = viewB.getInt(\"ttY\");\n								}else if(m==0){\n									startBX = viewB.getInt(\"tsX\");\n									startBY = viewB.getInt(\"tsY\");\n									endBX = vtB.getJSONObject(0).getInt(\"x\");\n									endBY = vtB.getJSONObject(0).getInt(\"y\");\n								}else if(m==vtB.size()){\n									startBX = vtB.getJSONObject(m-1).getInt(\"x\");\n									startBY = vtB.getJSONObject(m-1).getInt(\"y\");\n									endBX = viewB.getInt(\"ttX\");\n									endBY = viewB.getInt(\"ttY\");\n								}else{\n									startBX = vtB.getJSONObject(m-1).getInt(\"x\");\n									startBY = vtB.getJSONObject(m-1).getInt(\"y\");\n									endBX = vtB.getJSONObject(m).getInt(\"x\");\n									endBY = vtB.getJSONObject(m).getInt(\"y\");\n								}\n								\n								//通过得到两条折线段的八个点，计算出两条折线段的交点\n								Map<String,Object> juncMap = this.getJunctions(startAX.floatValue(), startAY.floatValue(), endAX.floatValue(), endAY.floatValue(), startBX.floatValue(), startBY.floatValue(), endBX.floatValue(), endBY.floatValue());\n								if((Boolean) juncMap.get(\"flag\")){\n									//如果存在交点\n									Map<String,Object> juncItem = new HashMap<String, Object>();\n									juncItem.put(\"AIndex\", k);//该相交折线段，在线A的排序顺序，即是线A的第几条折线，没有拐点，只有一条线时，index为0\n									juncItem.put(\"crossX\", juncMap.get(\"crossX\"));//交点横坐标\n									juncItem.put(\"crossY\", juncMap.get(\"crossY\"));//交点纵坐标\n									juncItem.put(\"zfFlagX\", juncMap.get(\"zfFlagX\"));\n									juncItem.put(\"zfFlagY\", juncMap.get(\"zfFlagY\"));\n									juncItem.put(\"zfFlagX2\", juncMap.get(\"zfFlagX2\"));\n									juncItem.put(\"zfFlagY2\", juncMap.get(\"zfFlagY2\"));\n									Integer ivy= endAY-startAY;\n									Integer ivx= endAX-startAX;\n									Integer ivy2= endBY-startBY;\n									Integer ivx2= endBX-startBX;\n									juncItem.put(\"k1\", (endAX-startAX==0)?\"max\":(ivy.doubleValue())/(ivx.doubleValue()));//折线段A的斜率，如果斜率无穷大，返回字符串max\n									juncItem.put(\"k2\", (endBX-startBX==0)?\"max\":(ivy2.doubleValue())/(ivx2.doubleValue()));//折线段B的斜率，如果斜率无穷大，返回字符串max\n									juncInfo.add(juncItem);//将交点信息放到list里面\n								}\n								\n							}\n						\n						\n					}\n					if(juncInfo.size()>0){\n						for(int l=0;l<juncInfo.size();l++){\n							Map<String,Object> juncItem = juncInfo.get(l);//得到第l个交点信息\n							Integer AIndex = (Integer) juncItem.get(\"AIndex\");//线A的第几个折线与其他线相交，aIndex是折线的index\n							Float crossX = (Float) juncItem.get(\"crossX\");//交点横坐标\n							Float crossY = (Float) juncItem.get(\"crossY\");//交点纵坐标\n							String k1 = String.valueOf(juncItem.get(\"k1\")) ;//线A相交折线的斜率\n							String k2 = String.valueOf(juncItem.get(\"k2\")) ;//线A相交折线的斜率\n							String zfFlagX = (String) juncItem.get(\"zfFlagX\");\n							String zfFlagY = (String) juncItem.get(\"zfFlagY\");\n							String zfFlagX2 = (String) juncItem.get(\"zfFlagX2\");\n							String zfFlagY2 = (String) juncItem.get(\"zfFlagY2\");\n							JSONArray jatmp = new JSONArray();\n							//以交点为中心，有两个关于交点对称两个折点也要插入vertices，形成三角形折线\n							JSONObject pointLeft = new JSONObject();//折线左端点，即三角形左顶点\n							JSONObject pointMid = new JSONObject();//三角形正顶点\n							JSONObject pointRight = new JSONObject();//折线右端点，即三角形右顶点\n							if(\"max\".equals(k1)){\n								//折线段斜率无穷大，是一条垂直于x轴的线\n								Float leftY = \"plus\".equals(zfFlagY)?crossY-10:crossY+10 ;\n								Float rightY = \"plus\".equals(zfFlagY)?crossY+10:crossY-10 ;\n								pointLeft.put(\"x\",crossX );\n								pointLeft.put(\"y\",leftY );//y轴越往上，值越小，所以是加号	\n								pointMid.put(\"x\", crossX-10);\n								pointMid.put(\"y\", crossY);\n								pointRight.put(\"x\", crossX);\n								pointRight.put(\"y\", rightY);\n							}else {\n								\n								Double kd = Double.valueOf(k1);\n								Double midY = 0.0 ;\n								Double midX =0.0;\n								//midX,midY为中间点坐标，以下用于得到中间点的x，y坐标\n								//中间点坐标特点是，该点在线B上。\n								if(\"max\".equals(k2)){\n									//当线B垂直x轴时\n									midX = crossX.doubleValue();\n									midY = \"plus\".equals(zfFlagY2)?crossY.doubleValue()+10:crossY.doubleValue()-10;\n								}else{\n									//利用三角函数算出顶点相对于交点的坐标偏移量\n									Double kd2 = Double.valueOf(k2);\n									Double midDx = Math.abs((8)/Math.sqrt(1+Math.pow(kd2, 2)));\n									Double midDy = Math.abs((8*kd2)/Math.sqrt(1+Math.pow(kd2, 2)));\n									midX = \"plus\".equals(zfFlagX2)?(crossX+midDx):(crossX-midDx);\n									midY = \"plus\".equals(zfFlagY2)?(crossY+midDy):(crossY-midDy);\n\n								}\n								\n								if(kd==0){\n									//斜率是零，是一条垂直于y轴，y值恒定的线\n									Float leftX = \"plus\".equals(zfFlagX)?crossX-10:crossX+10 ;\n									Float rightX = \"plus\".equals(zfFlagX)?crossX+10:crossX-10 ;\n									pointLeft.put(\"x\", leftX);\n									pointLeft.put(\"y\", crossY);\n									pointMid.put(\"x\", midX);\n									pointMid.put(\"y\", midY);\n									pointRight.put(\"x\", rightX);\n									pointRight.put(\"y\", crossY);\n								}else{\n									\n									\n									Double lrDx = Math.abs((5)/Math.sqrt(1+Math.pow(kd, 2)));//左右两端点的x偏移距离dx\n									Double lrDy = Math.abs((5*kd)/Math.sqrt(1+Math.pow(kd, 2)));//左右两端点的y偏移距离dy\n									Double leftY = \"plus\".equals(zfFlagY)?(crossY-lrDy):crossY+lrDy ;\n									Double rightY = \"plus\".equals(zfFlagY)?(crossY+lrDy):crossY-lrDy ;\n									Double leftX = \"plus\".equals(zfFlagX)?(crossX-lrDx):crossX+lrDx ;\n									Double rightX = \"plus\".equals(zfFlagX)?(crossX+lrDx):crossX-lrDx ;\n									//其它情况，根据斜率画出一个三角形，三角形中垂线垂直于折线\n									pointLeft.put(\"x\",leftX);\n									pointLeft.put(\"y\",leftY );	//	y轴越往上，值越小，所以是加号		\n									pointMid.put(\"x\",midX );\n									pointMid.put(\"y\", midY);//	y轴越往上，值越小，所以是加号	\n									pointRight.put(\"x\", rightX);\n									pointRight.put(\"y\",rightY);//	y轴越往上，值越小，所以是加号	\n								}\n							}\n							//算出三个折点后，添加到线A的vetices里面\n							jatmp.add(pointLeft);\n							jatmp.add(pointMid);\n							jatmp.add(pointRight);\n							vtA.addAll(AIndex, jatmp);//将三个点加到一个jsonArray,再使用addAll加到原来的vetices里面\n							objA.put(\"ifCross\", \"yes\");\n							objB.put(\"ifCross\", \"yes\");\n						}\n					}\n			}\n		}\n		map.put(\"links\", link);\n		return map;\n	}\n\n```\n求两条线交点方法\n```javaScript\npublic  Map<String,Object> getJunctions(Float startAX,Float startAY,Float endAX,Float endAY,Float startBX,Float startBY,Float endBX,Float endBY){\n		Map<String,Object> map = new HashMap<String, Object>();\n		boolean crossFlag = false;\n		float x;//焦点x坐标\n		float y ;//焦点y坐标\n		float k1 = Float.MAX_VALUE ;//第一条线斜率\n		float k2 = Float.MAX_VALUE;//第2条线斜率\n		boolean flag1=true;\n		boolean flag2=true;\n		if(startAX - endAX==0){\n			flag1 = false;//线A垂直x轴时，斜率无穷大，flag1为false\n		}\n		if(startBX - endBX==0){\n			flag2 = false;//线B垂直x轴时，斜率无穷大，flag2为false\n		}\n		if(flag1){\n			k1 = (endAY-startAY)/(endAX-startAX);//有斜率时算出斜率\n		}\n		if(flag2){\n			k2 = (endBY-startBY)/(endBX-startBX);\n		}\n		if(k1==k2&&k1!=Float.MAX_VALUE){\n			\n			map.put(\"flag\", crossFlag);//都存在斜率，且斜率相等时，不想交\n			return map;\n		}\n		if(!flag1){\n			if(!flag2){\n				map.put(\"flag\", crossFlag);//都斜率无穷大时，不相交\n				return map;\n			}else{\n				x = startAX;//线A垂直于x轴时，x恒定\n				if(k2==0){\n					y = endBY;//线B垂直于y轴，y恒定\n				}else{\n					y=k2*(x-endBX)+endBY;//线B不垂直于y轴，根据B上的点，算出交点纵坐标\n				}\n			}\n		}else if(!flag2){\n			//线B垂直于x轴时，x恒定\n			x = startBX;\n			if(k1==0){\n				y = startAY;//线A垂直于y轴，y恒定\n			}else{\n				y=k1*(x-endAX)+endAY;\n			}\n		}else{\n			if(k1==0){\n				y= startAY;//线A垂直于y轴\n				x = (y-endBY)/k2+endBX;\n			}else if(k2==0){\n				y = startBY;//线B垂直于y轴\n				x = (y-endAY)/k1+endAX;\n			}else{\n				//常规情况\n				x = (k1*endAX-k2*endBX+endBY-endAY)/(k1-k2);\n				y = k1*(x-endAX)+endAY;\n			}\n		}\n		if(between(startAX,endAX,x)&&between(startAY,endAY,y)&&between(startBX,endBX,x)&&between(startBY,endBY,y)){\n			map.put(\"crossX\", x);//交点\n			map.put(\"crossY\", y);\n			map.put(\"flag\", true);\n			String zfFlagY = (endAY-startAY)>0?\"plus\":\"minus\";//线A y坐标走势（增加还是减少）\n			String zfFlagX = (endAX-startAX)>0?\"plus\":\"minus\";//线A x坐标走势\n			String zfFlagY2 = (endBY-startBY)>0?\"plus\":\"minus\";//线B x坐标走势\n			String zfFlagX2 = (endBX-startBX)>0?\"plus\":\"minus\";//线B y坐标走势\n			map.put(\"zfFlagY\", zfFlagY);\n			map.put(\"zfFlagX\", zfFlagX);\n			map.put(\"zfFlagY2\", zfFlagY2);\n			map.put(\"zfFlagX2\", zfFlagX2);\n		}else{\n			map.put(\"flag\", false);\n		}\n		return map;\n	}\n\n```\n判断交点是否在两线段范围内的方法：\n```javaScript\npublic static boolean between(float a,float b,float target){\n		if(target>=a-0.01&&target<=b+0.01||target<=a+0.01&&target>=b-0.01)\n			return true;\n		else \n			return false;\n	}\n\n```\n最后效果图\n![joint2.jpg](/uploads/2019/02/8cb77e4e3a602d21e8ab2d5562b147a6.jpg)\n\n四.总结 \n\n    本文需要对jointJs有一定了解的朋友阅读，jointJs简介以及demo可见我的博客--JointJS简介与实例 （还没写）。这种处理连线交点的方法有局限性，最大的局限性是不能实时处理两线相交。除此之外，本方法还有许多未完善的地方，有兴趣我会自己完善（暂时没兴趣）。', '<pre><code>使用jointJs绘制流程图时，如果两条连线相交，这两条线不会像Viso一样，对交点进行处理（交点处有弧线）。虽然鼠标选中连线时，单条线会有自动点亮的效果，但是在客户强烈要求下（！！！），我还是做了保存时对两条线交点的处理。</code></pre><!--more-->\n<p>一.问题概述\n    本处理方法生效有几个前提</p><pre><code><span class=\"hljs-selector-tag\">1</span>.本方法实质是在保存时，把连线的属性<span class=\"hljs-selector-tag\">vertices</span>(即保存折点信息的属性)改变,并存到数据库。所以只适用于保存时，并非在两条线相交时实时触发。\n\n<span class=\"hljs-selector-tag\">2</span>.本方法不适用于大于两条线交于一点。\n\n<span class=\"hljs-selector-tag\">3</span>.本方法不适用于<span class=\"hljs-selector-tag\">n</span>条直线相交，产生<span class=\"hljs-selector-tag\">n</span>个交点（<span class=\"hljs-selector-tag\">n</span>&gt;<span class=\"hljs-selector-tag\">2</span>）。其实这个是可以实现的，只是客户没有这个需求，我也懒得写。\n\n<span class=\"hljs-selector-tag\">4</span>.交点处会折成三角形凸起，而不是<span class=\"hljs-selector-tag\">Viso</span>一样的弧（能力有限）,如下图所示。</code></pre><p>​​​​​<img src=\"/uploads/2019/02/c0ec89292bb71333a2c718ce49fd7134.jpg\" alt=\"joint01.jpg\">\n    5.两条线相交后，如果改变线的位置，保存时两线交点位置不会随着两线的位置改变。因为无法区分vertices里面的折点是人为折的还是自动计算生成的交线折点。需要删掉折叠的线，再连接一次，再保存。（应该也可以做，但是客户没要求）\n二.解决方法整体思路 </p><pre><code>  因为<span class=\"hljs-selector-tag\">jointJs</span>并没有对于两条线相交的监听事件，也没有得到<span class=\"hljs-selector-tag\">graph</span>上所有交点的方法，所以只能通过计算得到两条线的交点坐标。\n\n首先需要得到每条线的起点，终点，以及该线的折点(vertices)。将每条线当做一个数组，存储着一个个线段。具体来说，比如线<span class=\"hljs-selector-tag\">A</span>有一个折点，起点到折点<span class=\"hljs-selector-tag\">1</span>算是一个线段，折点一到终点是一个线段，所以线<span class=\"hljs-selector-tag\">A</span>的数组有两个线段元素。\n\n先用双重循环使得每两条线相遇一次（取出两条线，并且这两条线的组合不重复）。取出相遇的两条线，线<span class=\"hljs-selector-tag\">A</span>与线<span class=\"hljs-selector-tag\">B</span>。再通过两重循环，将线<span class=\"hljs-selector-tag\">A</span>的每条线段，与线<span class=\"hljs-selector-tag\">B</span>的每条线段相遇（同样不重复）。这样我们得到了分别来自两条线的两条线段，也得到了两条线段的起点，终点 共四个点坐标值。通过计算，得到两条线段的交点坐标。\n\n如果想让线<span class=\"hljs-selector-tag\">A</span>折叠，则通过线<span class=\"hljs-selector-tag\">B</span>的折线斜率计算得到中间折点两侧的两个折点的坐标值。通过线<span class=\"hljs-selector-tag\">A</span>的斜率得到交点上方，中心折点的坐标，使得中间折点在线<span class=\"hljs-selector-tag\">A</span>上。得到三个折点后，保存到连线（<span class=\"hljs-selector-tag\">link</span>）的<span class=\"hljs-selector-tag\">vertices</span>属性里，刷新后交点就出现了。</code></pre><p>三.代码部分</p><pre><code>1.前端：\n\n    前端代码的难点在于得到连线的准确起点坐标与终点坐标。因为<span class=\"hljs-selector-tag\">graph</span><span class=\"hljs-selector-class\">.getLinks</span>()方法只是得到<span class=\"hljs-selector-tag\">link</span>的<span class=\"hljs-selector-tag\">model</span>，而<span class=\"hljs-selector-tag\">model</span>里面只有<span class=\"hljs-selector-tag\">sourceId</span>,<span class=\"hljs-selector-tag\">targetId</span> 也就是连线的起点图形和终点图形的图形<span class=\"hljs-selector-tag\">id</span>。图形坐标肯定不是连线起点或者终点的准确坐标。在查找<span class=\"hljs-selector-tag\">JointJs</span> <span class=\"hljs-selector-tag\">API</span>后，发现<span class=\"hljs-selector-tag\">link</span> 的<span class=\"hljs-selector-tag\">view</span>里面存着<span class=\"hljs-selector-tag\">sourcePoint</span>,<span class=\"hljs-selector-tag\">targetPoint</span> 属性，分别存着起始点的坐标值。于是代码中，首先通过<span class=\"hljs-selector-tag\">link</span> 的<span class=\"hljs-selector-tag\">model</span>得到<span class=\"hljs-selector-tag\">view</span>，再将<span class=\"hljs-selector-tag\">view</span>里面的起终点坐标值传到后台。\n\n代码如下：</code></pre><pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">saveLC</span> (<span class=\"hljs-params\"></span>)</span>{\n            <span class=\"hljs-keyword\">if</span>(TREENODE==<span class=\"hljs-literal\">null</span>||TREENODE.type!=<span class=\"hljs-number\">5</span>){\n                app.graph.fromJSON(<span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-string\">\"{\\\"cells\\\":[]} \"</span>));\n                layer.alert(<span class=\"hljs-string\">\"当前树节点无法保存流程信息！\"</span>);\n            <span class=\"hljs-keyword\">return</span>\n            }\n            <span class=\"hljs-keyword\">var</span> t = app.graph.getCellsBBox();\n            <span class=\"hljs-keyword\">var</span> xxx= app.graph.getLinks();\n            <span class=\"hljs-keyword\">var</span> mapA = {};\n             <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;xxx.length;i++){\n                <span class=\"hljs-keyword\">var</span> mapT = {}; \n                <span class=\"hljs-keyword\">var</span> u=xxx[i];\n                <span class=\"hljs-keyword\">var</span> vv=u.findView(app.paper);<span class=\"hljs-comment\">//通过model得到view </span>\n                <span class=\"hljs-comment\">//通过view得到link的起点终点坐标</span>\n                <span class=\"hljs-keyword\">var</span> tsX=vv.sourcePoint.x;\n                <span class=\"hljs-keyword\">var</span> tsY=vv.sourcePoint.y;\n                <span class=\"hljs-keyword\">var</span> ttX=vv.targetPoint.x;\n                <span class=\"hljs-keyword\">var</span> ttY=vv.targetPoint.y;\n                mapT[<span class=\"hljs-string\">\"tsX\"</span>] = tsX;\n                mapT[<span class=\"hljs-string\">\"tsY\"</span>] = tsY;\n                mapT[<span class=\"hljs-string\">\"ttX\"</span>] = ttX;\n                mapT[<span class=\"hljs-string\">\"ttY\"</span>] = ttY;\n                mapA[u.id] = mapT;\n            } \n             <span class=\"hljs-keyword\">var</span> lv = <span class=\"hljs-built_in\">JSON</span>.stringify(mapA);\n            $.ajax({<span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">\"POST\"</span>,<span class=\"hljs-attr\">url</span>:<span class=\"hljs-string\">\"saveLC.do\"</span>,\n                <span class=\"hljs-attr\">data</span> :{<span class=\"hljs-attr\">lcid</span>:TREENODE.id,<span class=\"hljs-string\">\'elements\'</span>:<span class=\"hljs-built_in\">JSON</span>.stringify(app.graph.getElements()),\n                         <span class=\"hljs-string\">\'links\'</span>:<span class=\"hljs-built_in\">JSON</span>.stringify(app.graph.getLinks()),<span class=\"hljs-string\">\'linksView\'</span>:lv},\n                <span class=\"hljs-attr\">dataType</span>:<span class=\"hljs-string\">\"text\"</span>,<span class=\"hljs-attr\">success</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>{\n                    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"false\"</span>!=data){                \n                    layer.msg(<span class=\"hljs-string\">\"保存成功!\"</span>);\n                    refreshPaper();\n                    ifChange =<span class=\"hljs-literal\">false</span>;\n                    $(<span class=\"hljs-string\">\"#btn-edit-page\"</span>).html(<span class=\"hljs-string\">\"修改\"</span>);\n                    }<span class=\"hljs-keyword\">else</span>{\n                        layer.msg(<span class=\"hljs-string\">\"保存失败!该流程不存在或已删除!\"</span>);\n                    }\n                }\n            });\n        }</code></pre>\n<p>2.后端</p><p>后端具体思路上文已经交代，代码上把判断两线段交点的方法，单独抽出来作为一个方法，同时抽出来判断交点在不在线段起终点之间的方法，便于判断交点是否可取。主要代码我写在了service里，具体代码如下：</p><pre><code class=\"language-javaScript\">\n\n\npublic <span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; handleJunction(JSONArray link,JSONObject linkView){\n        <span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt;();\n        <span class=\"hljs-keyword\">for</span>(int i=<span class=\"hljs-number\">0</span>;i&lt;link.size()<span class=\"hljs-number\">-1</span>;i++){\n            <span class=\"hljs-keyword\">for</span>(int j=i+<span class=\"hljs-number\">1</span>;j&lt;link.size();j++){\n                <span class=\"hljs-comment\">//所有的线，两两碰面，计算线中折线段是否相交</span>\n                JSONObject objA = link.getJSONObject(i);<span class=\"hljs-comment\">//线A</span>\n                JSONObject objB = link.getJSONObject(j);<span class=\"hljs-comment\">//线B</span>\n                <span class=\"hljs-built_in\">String</span> ifACross = objA.getString(<span class=\"hljs-string\">\"ifCross\"</span>);\n                <span class=\"hljs-built_in\">String</span> ifBCross = objB.getString(<span class=\"hljs-string\">\"ifCross\"</span>);\n                <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-string\">\"no\"</span>.equals(ifACross)&amp;&amp;!<span class=\"hljs-string\">\"no\"</span>.equals(ifBCross)){\n                    <span class=\"hljs-comment\">//已经相交的线，不再判断了</span>\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n                <span class=\"hljs-built_in\">String</span> idA = objA.getString(<span class=\"hljs-string\">\"id\"</span>);<span class=\"hljs-comment\">//线A 的id </span>\n                JSONObject viewA = linkView.getJSONObject(idA);<span class=\"hljs-comment\">//线A的起点，终点坐标信息</span>\n\n                <span class=\"hljs-built_in\">String</span> idB = objB.getString(<span class=\"hljs-string\">\"id\"</span>);<span class=\"hljs-comment\">//线B 的id </span>\n                JSONObject viewB = linkView.getJSONObject(idB);<span class=\"hljs-comment\">//线B的起点，终点坐标信息</span>\n                JSONArray vtA = objA.getJSONArray(<span class=\"hljs-string\">\"vertices\"</span>);<span class=\"hljs-comment\">//线A vetices 的json数组信息</span>\n                JSONArray vtB = objB.getJSONArray(<span class=\"hljs-string\">\"vertices\"</span>);<span class=\"hljs-comment\">//线B vetices 的json数组信息</span>\n                List&lt;<span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt;&gt; juncInfo = <span class=\"hljs-keyword\">new</span> ArrayList&lt;<span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt;&gt;();<span class=\"hljs-comment\">//取得的交点信息放到list里面</span>\n<span class=\"hljs-comment\">//                if(vtA.size()&gt;0){</span>\n                    Integer startAX = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//初始化线A 折线段的起点x轴坐标</span>\n                    Integer startAY = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//折线段的起点y轴坐标</span>\n                    Integer endAX = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//初始化线A 折线段的终点x轴坐标</span>\n                    Integer endAY = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//初始化线A 折线段的终点y轴坐标</span>\n                    <span class=\"hljs-keyword\">for</span>(int k=<span class=\"hljs-number\">0</span>;k&lt;vtA.size()+<span class=\"hljs-number\">1</span>;k++){\n                        <span class=\"hljs-comment\">//循环vertices信息，即折线拐点信息</span>\n                        <span class=\"hljs-keyword\">if</span>(vtA.size() == <span class=\"hljs-number\">0</span>){\n                            <span class=\"hljs-comment\">//当没有拐点时，折线的起点终点，就是线A的起点终点</span>\n                            startAX = viewA.getInt(<span class=\"hljs-string\">\"tsX\"</span>);\n                            startAY = viewA.getInt(<span class=\"hljs-string\">\"tsY\"</span>);\n                            endAX = viewA.getInt(<span class=\"hljs-string\">\"ttX\"</span>);\n                            endAY = viewA.getInt(<span class=\"hljs-string\">\"ttY\"</span>);\n                        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>){\n                            <span class=\"hljs-comment\">//有拐点时，第一次循环，折线起点是线A起点，折线终点是第一个拐点</span>\n                            startAX = viewA.getInt(<span class=\"hljs-string\">\"tsX\"</span>);\n                            startAY = viewA.getInt(<span class=\"hljs-string\">\"tsY\"</span>);\n                            endAX = vtA.getJSONObject(<span class=\"hljs-number\">0</span>).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                            endAY = vtA.getJSONObject(<span class=\"hljs-number\">0</span>).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k==vtA.size()){\n                            <span class=\"hljs-comment\">//最后一次循环，折线起点是最后一个拐点，折线终点是线A的终点</span>\n                            startAX = vtA.getJSONObject(k<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                            startAY = vtA.getJSONObject(k<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                            endAX = viewA.getInt(<span class=\"hljs-string\">\"ttX\"</span>);\n                            endAY = viewA.getInt(<span class=\"hljs-string\">\"ttY\"</span>);\n                        }<span class=\"hljs-keyword\">else</span>{\n                            <span class=\"hljs-comment\">//其它情况，起点是第k-1个拐点，终点是第k个拐点</span>\n                            startAX = vtA.getJSONObject(k<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                            startAY = vtA.getJSONObject(k<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                            endAX = vtA.getJSONObject(k).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                            endAY = vtA.getJSONObject(k).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                        }\n                        <span class=\"hljs-comment\">//初始化线B的折线起，终点</span>\n                        Integer startBX = <span class=\"hljs-number\">-1</span>;\n                        Integer startBY = <span class=\"hljs-number\">-1</span>;\n                        Integer endBX = <span class=\"hljs-number\">-1</span>;\n                        Integer endBY = <span class=\"hljs-number\">-1</span>;\n\n                            <span class=\"hljs-keyword\">for</span>(int m=<span class=\"hljs-number\">0</span>;m&lt;vtB.size()+<span class=\"hljs-number\">1</span>;m++){\n                                <span class=\"hljs-comment\">//同理线A,得到折线的起点，终点</span>\n                                <span class=\"hljs-keyword\">if</span>(vtB.size()==<span class=\"hljs-number\">0</span>){\n                                    startBX = viewB.getInt(<span class=\"hljs-string\">\"tsX\"</span>);\n                                    startBY = viewB.getInt(<span class=\"hljs-string\">\"tsY\"</span>);\n                                    endBX = viewB.getInt(<span class=\"hljs-string\">\"ttX\"</span>);\n                                    endBY = viewB.getInt(<span class=\"hljs-string\">\"ttY\"</span>);\n                                }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(m==<span class=\"hljs-number\">0</span>){\n                                    startBX = viewB.getInt(<span class=\"hljs-string\">\"tsX\"</span>);\n                                    startBY = viewB.getInt(<span class=\"hljs-string\">\"tsY\"</span>);\n                                    endBX = vtB.getJSONObject(<span class=\"hljs-number\">0</span>).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                                    endBY = vtB.getJSONObject(<span class=\"hljs-number\">0</span>).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                                }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(m==vtB.size()){\n                                    startBX = vtB.getJSONObject(m<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                                    startBY = vtB.getJSONObject(m<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                                    endBX = viewB.getInt(<span class=\"hljs-string\">\"ttX\"</span>);\n                                    endBY = viewB.getInt(<span class=\"hljs-string\">\"ttY\"</span>);\n                                }<span class=\"hljs-keyword\">else</span>{\n                                    startBX = vtB.getJSONObject(m<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                                    startBY = vtB.getJSONObject(m<span class=\"hljs-number\">-1</span>).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                                    endBX = vtB.getJSONObject(m).getInt(<span class=\"hljs-string\">\"x\"</span>);\n                                    endBY = vtB.getJSONObject(m).getInt(<span class=\"hljs-string\">\"y\"</span>);\n                                }\n\n                                <span class=\"hljs-comment\">//通过得到两条折线段的八个点，计算出两条折线段的交点</span>\n                                <span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; juncMap = <span class=\"hljs-keyword\">this</span>.getJunctions(startAX.floatValue(), startAY.floatValue(), endAX.floatValue(), endAY.floatValue(), startBX.floatValue(), startBY.floatValue(), endBX.floatValue(), endBY.floatValue());\n                                <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-built_in\">Boolean</span>) juncMap.get(<span class=\"hljs-string\">\"flag\"</span>)){\n                                    <span class=\"hljs-comment\">//如果存在交点</span>\n                                    <span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; juncItem = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt;();\n                                    juncItem.put(<span class=\"hljs-string\">\"AIndex\"</span>, k);<span class=\"hljs-comment\">//该相交折线段，在线A的排序顺序，即是线A的第几条折线，没有拐点，只有一条线时，index为0</span>\n                                    juncItem.put(<span class=\"hljs-string\">\"crossX\"</span>, juncMap.get(<span class=\"hljs-string\">\"crossX\"</span>));<span class=\"hljs-comment\">//交点横坐标</span>\n                                    juncItem.put(<span class=\"hljs-string\">\"crossY\"</span>, juncMap.get(<span class=\"hljs-string\">\"crossY\"</span>));<span class=\"hljs-comment\">//交点纵坐标</span>\n                                    juncItem.put(<span class=\"hljs-string\">\"zfFlagX\"</span>, juncMap.get(<span class=\"hljs-string\">\"zfFlagX\"</span>));\n                                    juncItem.put(<span class=\"hljs-string\">\"zfFlagY\"</span>, juncMap.get(<span class=\"hljs-string\">\"zfFlagY\"</span>));\n                                    juncItem.put(<span class=\"hljs-string\">\"zfFlagX2\"</span>, juncMap.get(<span class=\"hljs-string\">\"zfFlagX2\"</span>));\n                                    juncItem.put(<span class=\"hljs-string\">\"zfFlagY2\"</span>, juncMap.get(<span class=\"hljs-string\">\"zfFlagY2\"</span>));\n                                    Integer ivy= endAY-startAY;\n                                    Integer ivx= endAX-startAX;\n                                    Integer ivy2= endBY-startBY;\n                                    Integer ivx2= endBX-startBX;\n                                    juncItem.put(<span class=\"hljs-string\">\"k1\"</span>, (endAX-startAX==<span class=\"hljs-number\">0</span>)?<span class=\"hljs-string\">\"max\"</span>:(ivy.doubleValue())/(ivx.doubleValue()));<span class=\"hljs-comment\">//折线段A的斜率，如果斜率无穷大，返回字符串max</span>\n                                    juncItem.put(<span class=\"hljs-string\">\"k2\"</span>, (endBX-startBX==<span class=\"hljs-number\">0</span>)?<span class=\"hljs-string\">\"max\"</span>:(ivy2.doubleValue())/(ivx2.doubleValue()));<span class=\"hljs-comment\">//折线段B的斜率，如果斜率无穷大，返回字符串max</span>\n                                    juncInfo.add(juncItem);<span class=\"hljs-comment\">//将交点信息放到list里面</span>\n                                }\n\n                            }\n\n\n                    }\n                    <span class=\"hljs-keyword\">if</span>(juncInfo.size()&gt;<span class=\"hljs-number\">0</span>){\n                        <span class=\"hljs-keyword\">for</span>(int l=<span class=\"hljs-number\">0</span>;l&lt;juncInfo.size();l++){\n                            <span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; juncItem = juncInfo.get(l);<span class=\"hljs-comment\">//得到第l个交点信息</span>\n                            Integer AIndex = (Integer) juncItem.get(<span class=\"hljs-string\">\"AIndex\"</span>);<span class=\"hljs-comment\">//线A的第几个折线与其他线相交，aIndex是折线的index</span>\n                            Float crossX = (Float) juncItem.get(<span class=\"hljs-string\">\"crossX\"</span>);<span class=\"hljs-comment\">//交点横坐标</span>\n                            Float crossY = (Float) juncItem.get(<span class=\"hljs-string\">\"crossY\"</span>);<span class=\"hljs-comment\">//交点纵坐标</span>\n                            <span class=\"hljs-built_in\">String</span> k1 = <span class=\"hljs-built_in\">String</span>.valueOf(juncItem.get(<span class=\"hljs-string\">\"k1\"</span>)) ;<span class=\"hljs-comment\">//线A相交折线的斜率</span>\n                            <span class=\"hljs-built_in\">String</span> k2 = <span class=\"hljs-built_in\">String</span>.valueOf(juncItem.get(<span class=\"hljs-string\">\"k2\"</span>)) ;<span class=\"hljs-comment\">//线A相交折线的斜率</span>\n                            <span class=\"hljs-built_in\">String</span> zfFlagX = (<span class=\"hljs-built_in\">String</span>) juncItem.get(<span class=\"hljs-string\">\"zfFlagX\"</span>);\n                            <span class=\"hljs-built_in\">String</span> zfFlagY = (<span class=\"hljs-built_in\">String</span>) juncItem.get(<span class=\"hljs-string\">\"zfFlagY\"</span>);\n                            <span class=\"hljs-built_in\">String</span> zfFlagX2 = (<span class=\"hljs-built_in\">String</span>) juncItem.get(<span class=\"hljs-string\">\"zfFlagX2\"</span>);\n                            <span class=\"hljs-built_in\">String</span> zfFlagY2 = (<span class=\"hljs-built_in\">String</span>) juncItem.get(<span class=\"hljs-string\">\"zfFlagY2\"</span>);\n                            JSONArray jatmp = <span class=\"hljs-keyword\">new</span> JSONArray();\n                            <span class=\"hljs-comment\">//以交点为中心，有两个关于交点对称两个折点也要插入vertices，形成三角形折线</span>\n                            JSONObject pointLeft = <span class=\"hljs-keyword\">new</span> JSONObject();<span class=\"hljs-comment\">//折线左端点，即三角形左顶点</span>\n                            JSONObject pointMid = <span class=\"hljs-keyword\">new</span> JSONObject();<span class=\"hljs-comment\">//三角形正顶点</span>\n                            JSONObject pointRight = <span class=\"hljs-keyword\">new</span> JSONObject();<span class=\"hljs-comment\">//折线右端点，即三角形右顶点</span>\n                            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"max\"</span>.equals(k1)){\n                                <span class=\"hljs-comment\">//折线段斜率无穷大，是一条垂直于x轴的线</span>\n                                Float leftY = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagY)?crossY<span class=\"hljs-number\">-10</span>:crossY+<span class=\"hljs-number\">10</span> ;\n                                Float rightY = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagY)?crossY+<span class=\"hljs-number\">10</span>:crossY<span class=\"hljs-number\">-10</span> ;\n                                pointLeft.put(<span class=\"hljs-string\">\"x\"</span>,crossX );\n                                pointLeft.put(<span class=\"hljs-string\">\"y\"</span>,leftY );<span class=\"hljs-comment\">//y轴越往上，值越小，所以是加号    </span>\n                                pointMid.put(<span class=\"hljs-string\">\"x\"</span>, crossX<span class=\"hljs-number\">-10</span>);\n                                pointMid.put(<span class=\"hljs-string\">\"y\"</span>, crossY);\n                                pointRight.put(<span class=\"hljs-string\">\"x\"</span>, crossX);\n                                pointRight.put(<span class=\"hljs-string\">\"y\"</span>, rightY);\n                            }<span class=\"hljs-keyword\">else</span> {\n\n                                Double kd = Double.valueOf(k1);\n                                Double midY = <span class=\"hljs-number\">0.0</span> ;\n                                Double midX =<span class=\"hljs-number\">0.0</span>;\n                                <span class=\"hljs-comment\">//midX,midY为中间点坐标，以下用于得到中间点的x，y坐标</span>\n                                <span class=\"hljs-comment\">//中间点坐标特点是，该点在线B上。</span>\n                                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"max\"</span>.equals(k2)){\n                                    <span class=\"hljs-comment\">//当线B垂直x轴时</span>\n                                    midX = crossX.doubleValue();\n                                    midY = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagY2)?crossY.doubleValue()+<span class=\"hljs-number\">10</span>:crossY.doubleValue()<span class=\"hljs-number\">-10</span>;\n                                }<span class=\"hljs-keyword\">else</span>{\n                                    <span class=\"hljs-comment\">//利用三角函数算出顶点相对于交点的坐标偏移量</span>\n                                    Double kd2 = Double.valueOf(k2);\n                                    Double midDx = <span class=\"hljs-built_in\">Math</span>.abs((<span class=\"hljs-number\">8</span>)/<span class=\"hljs-built_in\">Math</span>.sqrt(<span class=\"hljs-number\">1</span>+<span class=\"hljs-built_in\">Math</span>.pow(kd2, <span class=\"hljs-number\">2</span>)));\n                                    Double midDy = <span class=\"hljs-built_in\">Math</span>.abs((<span class=\"hljs-number\">8</span>*kd2)/<span class=\"hljs-built_in\">Math</span>.sqrt(<span class=\"hljs-number\">1</span>+<span class=\"hljs-built_in\">Math</span>.pow(kd2, <span class=\"hljs-number\">2</span>)));\n                                    midX = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagX2)?(crossX+midDx):(crossX-midDx);\n                                    midY = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagY2)?(crossY+midDy):(crossY-midDy);\n\n                                }\n\n                                <span class=\"hljs-keyword\">if</span>(kd==<span class=\"hljs-number\">0</span>){\n                                    <span class=\"hljs-comment\">//斜率是零，是一条垂直于y轴，y值恒定的线</span>\n                                    Float leftX = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagX)?crossX<span class=\"hljs-number\">-10</span>:crossX+<span class=\"hljs-number\">10</span> ;\n                                    Float rightX = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagX)?crossX+<span class=\"hljs-number\">10</span>:crossX<span class=\"hljs-number\">-10</span> ;\n                                    pointLeft.put(<span class=\"hljs-string\">\"x\"</span>, leftX);\n                                    pointLeft.put(<span class=\"hljs-string\">\"y\"</span>, crossY);\n                                    pointMid.put(<span class=\"hljs-string\">\"x\"</span>, midX);\n                                    pointMid.put(<span class=\"hljs-string\">\"y\"</span>, midY);\n                                    pointRight.put(<span class=\"hljs-string\">\"x\"</span>, rightX);\n                                    pointRight.put(<span class=\"hljs-string\">\"y\"</span>, crossY);\n                                }<span class=\"hljs-keyword\">else</span>{\n\n\n                                    Double lrDx = <span class=\"hljs-built_in\">Math</span>.abs((<span class=\"hljs-number\">5</span>)/<span class=\"hljs-built_in\">Math</span>.sqrt(<span class=\"hljs-number\">1</span>+<span class=\"hljs-built_in\">Math</span>.pow(kd, <span class=\"hljs-number\">2</span>)));<span class=\"hljs-comment\">//左右两端点的x偏移距离dx</span>\n                                    Double lrDy = <span class=\"hljs-built_in\">Math</span>.abs((<span class=\"hljs-number\">5</span>*kd)/<span class=\"hljs-built_in\">Math</span>.sqrt(<span class=\"hljs-number\">1</span>+<span class=\"hljs-built_in\">Math</span>.pow(kd, <span class=\"hljs-number\">2</span>)));<span class=\"hljs-comment\">//左右两端点的y偏移距离dy</span>\n                                    Double leftY = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagY)?(crossY-lrDy):crossY+lrDy ;\n                                    Double rightY = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagY)?(crossY+lrDy):crossY-lrDy ;\n                                    Double leftX = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagX)?(crossX-lrDx):crossX+lrDx ;\n                                    Double rightX = <span class=\"hljs-string\">\"plus\"</span>.equals(zfFlagX)?(crossX+lrDx):crossX-lrDx ;\n                                    <span class=\"hljs-comment\">//其它情况，根据斜率画出一个三角形，三角形中垂线垂直于折线</span>\n                                    pointLeft.put(<span class=\"hljs-string\">\"x\"</span>,leftX);\n                                    pointLeft.put(<span class=\"hljs-string\">\"y\"</span>,leftY );    <span class=\"hljs-comment\">//    y轴越往上，值越小，所以是加号        </span>\n                                    pointMid.put(<span class=\"hljs-string\">\"x\"</span>,midX );\n                                    pointMid.put(<span class=\"hljs-string\">\"y\"</span>, midY);<span class=\"hljs-comment\">//    y轴越往上，值越小，所以是加号    </span>\n                                    pointRight.put(<span class=\"hljs-string\">\"x\"</span>, rightX);\n                                    pointRight.put(<span class=\"hljs-string\">\"y\"</span>,rightY);<span class=\"hljs-comment\">//    y轴越往上，值越小，所以是加号    </span>\n                                }\n                            }\n                            <span class=\"hljs-comment\">//算出三个折点后，添加到线A的vetices里面</span>\n                            jatmp.add(pointLeft);\n                            jatmp.add(pointMid);\n                            jatmp.add(pointRight);\n                            vtA.addAll(AIndex, jatmp);<span class=\"hljs-comment\">//将三个点加到一个jsonArray,再使用addAll加到原来的vetices里面</span>\n                            objA.put(<span class=\"hljs-string\">\"ifCross\"</span>, <span class=\"hljs-string\">\"yes\"</span>);\n                            objB.put(<span class=\"hljs-string\">\"ifCross\"</span>, <span class=\"hljs-string\">\"yes\"</span>);\n                        }\n                    }\n            }\n        }\n        map.put(<span class=\"hljs-string\">\"links\"</span>, link);\n        <span class=\"hljs-keyword\">return</span> map;\n    }\n</code></pre>\n<p>求两条线交点方法</p><pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">public</span>  Map&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; getJunctions(Float startAX,Float startAY,Float endAX,Float endAY,Float startBX,Float startBY,Float endBX,Float endBY){\n        Map&lt;<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Object</span>&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt;();\n        <span class=\"hljs-built_in\">boolean</span> crossFlag = <span class=\"hljs-literal\">false</span>;\n        float x;<span class=\"hljs-comment\">//焦点x坐标</span>\n        float y ;<span class=\"hljs-comment\">//焦点y坐标</span>\n        float k1 = Float.MAX_VALUE ;<span class=\"hljs-comment\">//第一条线斜率</span>\n        float k2 = Float.MAX_VALUE;<span class=\"hljs-comment\">//第2条线斜率</span>\n        <span class=\"hljs-built_in\">boolean</span> flag1=<span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-built_in\">boolean</span> flag2=<span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">if</span>(startAX - endAX==<span class=\"hljs-number\">0</span>){\n            flag1 = <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//线A垂直x轴时，斜率无穷大，flag1为false</span>\n        }\n        <span class=\"hljs-keyword\">if</span>(startBX - endBX==<span class=\"hljs-number\">0</span>){\n            flag2 = <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//线B垂直x轴时，斜率无穷大，flag2为false</span>\n        }\n        <span class=\"hljs-keyword\">if</span>(flag1){\n            k1 = (endAY-startAY)/(endAX-startAX);<span class=\"hljs-comment\">//有斜率时算出斜率</span>\n        }\n        <span class=\"hljs-keyword\">if</span>(flag2){\n            k2 = (endBY-startBY)/(endBX-startBX);\n        }\n        <span class=\"hljs-keyword\">if</span>(k1==k2&amp;&amp;k1!=Float.MAX_VALUE){\n\n            map.put(<span class=\"hljs-string\">\"flag\"</span>, crossFlag);<span class=\"hljs-comment\">//都存在斜率，且斜率相等时，不想交</span>\n            <span class=\"hljs-keyword\">return</span> map;\n        }\n        <span class=\"hljs-keyword\">if</span>(!flag1){\n            <span class=\"hljs-keyword\">if</span>(!flag2){\n                map.put(<span class=\"hljs-string\">\"flag\"</span>, crossFlag);<span class=\"hljs-comment\">//都斜率无穷大时，不相交</span>\n                <span class=\"hljs-keyword\">return</span> map;\n            }<span class=\"hljs-keyword\">else</span>{\n                x = startAX;<span class=\"hljs-comment\">//线A垂直于x轴时，x恒定</span>\n                <span class=\"hljs-keyword\">if</span>(k2==<span class=\"hljs-number\">0</span>){\n                    y = endBY;<span class=\"hljs-comment\">//线B垂直于y轴，y恒定</span>\n                }<span class=\"hljs-keyword\">else</span>{\n                    y=k2*(x-endBX)+endBY;<span class=\"hljs-comment\">//线B不垂直于y轴，根据B上的点，算出交点纵坐标</span>\n                }\n            }\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(!flag2){\n            <span class=\"hljs-comment\">//线B垂直于x轴时，x恒定</span>\n            x = startBX;\n            <span class=\"hljs-keyword\">if</span>(k1==<span class=\"hljs-number\">0</span>){\n                y = startAY;<span class=\"hljs-comment\">//线A垂直于y轴，y恒定</span>\n            }<span class=\"hljs-keyword\">else</span>{\n                y=k1*(x-endAX)+endAY;\n            }\n        }<span class=\"hljs-keyword\">else</span>{\n            <span class=\"hljs-keyword\">if</span>(k1==<span class=\"hljs-number\">0</span>){\n                y= startAY;<span class=\"hljs-comment\">//线A垂直于y轴</span>\n                x = (y-endBY)/k2+endBX;\n            }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2==<span class=\"hljs-number\">0</span>){\n                y = startBY;<span class=\"hljs-comment\">//线B垂直于y轴</span>\n                x = (y-endAY)/k1+endAX;\n            }<span class=\"hljs-keyword\">else</span>{\n                <span class=\"hljs-comment\">//常规情况</span>\n                x = (k1*endAX-k2*endBX+endBY-endAY)/(k1-k2);\n                y = k1*(x-endAX)+endAY;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span>(between(startAX,endAX,x)&amp;&amp;between(startAY,endAY,y)&amp;&amp;between(startBX,endBX,x)&amp;&amp;between(startBY,endBY,y)){\n            map.put(<span class=\"hljs-string\">\"crossX\"</span>, x);<span class=\"hljs-comment\">//交点</span>\n            map.put(<span class=\"hljs-string\">\"crossY\"</span>, y);\n            map.put(<span class=\"hljs-string\">\"flag\"</span>, <span class=\"hljs-literal\">true</span>);\n            <span class=\"hljs-built_in\">String</span> zfFlagY = (endAY-startAY)&gt;<span class=\"hljs-number\">0</span>?<span class=\"hljs-string\">\"plus\"</span>:<span class=\"hljs-string\">\"minus\"</span>;<span class=\"hljs-comment\">//线A y坐标走势（增加还是减少）</span>\n            <span class=\"hljs-built_in\">String</span> zfFlagX = (endAX-startAX)&gt;<span class=\"hljs-number\">0</span>?<span class=\"hljs-string\">\"plus\"</span>:<span class=\"hljs-string\">\"minus\"</span>;<span class=\"hljs-comment\">//线A x坐标走势</span>\n            <span class=\"hljs-built_in\">String</span> zfFlagY2 = (endBY-startBY)&gt;<span class=\"hljs-number\">0</span>?<span class=\"hljs-string\">\"plus\"</span>:<span class=\"hljs-string\">\"minus\"</span>;<span class=\"hljs-comment\">//线B x坐标走势</span>\n            <span class=\"hljs-built_in\">String</span> zfFlagX2 = (endBX-startBX)&gt;<span class=\"hljs-number\">0</span>?<span class=\"hljs-string\">\"plus\"</span>:<span class=\"hljs-string\">\"minus\"</span>;<span class=\"hljs-comment\">//线B y坐标走势</span>\n            map.put(<span class=\"hljs-string\">\"zfFlagY\"</span>, zfFlagY);\n            map.put(<span class=\"hljs-string\">\"zfFlagX\"</span>, zfFlagX);\n            map.put(<span class=\"hljs-string\">\"zfFlagY2\"</span>, zfFlagY2);\n            map.put(<span class=\"hljs-string\">\"zfFlagX2\"</span>, zfFlagX2);\n        }<span class=\"hljs-keyword\">else</span>{\n            map.put(<span class=\"hljs-string\">\"flag\"</span>, <span class=\"hljs-literal\">false</span>);\n        }\n        <span class=\"hljs-keyword\">return</span> map;\n    }\n</code></pre>\n<p>判断交点是否在两线段范围内的方法：</p><pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">boolean</span> between(float a,float b,float target){\n        <span class=\"hljs-keyword\">if</span>(target&gt;=a<span class=\"hljs-number\">-0.01</span>&amp;&amp;target&lt;=b+<span class=\"hljs-number\">0.01</span>||target&lt;=a+<span class=\"hljs-number\">0.01</span>&amp;&amp;target&gt;=b<span class=\"hljs-number\">-0.01</span>)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">else</span> \n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n</code></pre>\n<p>最后效果图\n<img src=\"/uploads/2019/02/8cb77e4e3a602d21e8ab2d5562b147a6.jpg\" alt=\"joint2.jpg\"></p><p>四.总结 </p><pre><code>本文需要对jointJs有一定了解的朋友阅读，jointJs简介以及demo可见我的博客--JointJS简介与实例 （还没写）。这种处理连线交点的方法有局限性，最大的局限性是不能实时处理两线相交。除此之外，本方法还有许多未完善的地方，有兴趣我会自己完善（暂时没兴趣）。</code></pre>', '2019-05-23 11:49:59', '2019-05-27 12:00:37', 10, '2019-05-27 12:00:37', 'Y', NULL);
INSERT INTO `sx_content` VALUES (32, 'Vue组件实现分页', 1, '1596bcd49d3a13d78ca685aca3c63e29', '', 1, 99, 'post', '<p> 本方法利用vue的父子组件实现分页功能，UI来自bootstrap。实现效果是最大页数小于五时全部显示，分页只显示五个页数，具体页码显示范围根据当前页与最大页数来变换</p>', ' 本方法利用vue的父子组件实现分页功能，UI来自bootstrap。实现效果是最大页数小于五时全部显示，分页只显示五个页数，具体页码显示范围根据当前页与最大页数来变换\n<!--more-->\n一.介绍\n\n    效果如下图所示：\n![divide.jpg](/uploads/2019/02/02196667f88d740a0cb55cf1d2090e43.jpg)\n二.子组件部分\n```javaScript\n	Vue.component(\'page-divide\',{\n		props:[\'index\',\'maxpage\',\'curpage\'],\n		computed:{\n			pagelist:function(){	//控制页面显示页码范围的方法\n					if(this.maxpage<5){\n						return  this.index;\n						}else{\n							if(this.curpage-2<=0){\n								return this.index;\n							}else if(this.curpage+2>this.maxpage){\n								 return this.maxpage+this.index-5;\n							}else{\n								return this.curpage+this.index-3;\n							}\n						}\n			}\n		},\n		template:\'<li v-bind:class=\"{active:curpage==pagelist}\"><a  v-on:click=\"switchpage\">{{pagelist}}</a></li>\',\n		methods:{         \n			switchpage:function(){\n				this.$emit(\'switchpage\',this.pagelist);\n			}\n		}	\n	});\n\n```\n我们定义了一个标签名为page-divide的子组件由父组件传入三个属性，index:当前循环的下标,maxpage:最大页数,curpage:当前页面页码。子组件的属性pagelist,由根据computed计算得到，当前页等于pagelist时，模板的li标签样式变为active。点击模板中a标签，调用子组件switchpage方法，该方法触发父组件switchpage方法。\n二.父组件部分\n\n    首先创建父组件的vm实例，\n\n     父组件使用Dom元素作为模板：\n```html\n<center>\n	<div id=\"page\" onselectstart=\"return false\">\n		<nav aligh=\"center\" aria-lable=\"Page navigation\">\n			<ul align=\"center\" id=\"pager\" class=\"pagination\">\n				<li><a v-on:click=\"getData(currentpage-1)\">上一页</a></li>\n				<page-divide @switchpage=\"getData\" \n							 v-for=\"n in pagesize\" \n							 :key=\"n.index\" \n							 :index=\"n\"\n							 :maxpage=\"maxpage\" \n							 :curpage=\"currentpage\">\n				</page-divide>\n				<li><a @click=\"getData(currentpage+1)\">下一页</a></l>\n			</ul>\n		</nav>\n	</div>\n</center>\n\n```\nvue实例:\n```javaScript\nvar vmstand = new Vue({\n		el:\'#stand\',\n		data:{\n			currentpage:currentpage,\n			maxpage:0\n		},computed:{\n			pagesize:function(){\n				return this.maxpage>5?5:this.maxpage;\n			}\n			},\n		methods:{\n			getData:function(page){\n				this.currentpage=page;\n				var _self=this;\n				_self.flag=false;\n				$.ajax({type:\"POST\",url:\"staticInfoController/getPage.do\",\n					data : {\'pageSize\':1,\'currentPage\':page,\'params\':this.condition,\'type\':\'basic.Standard\'},async:false,\n					dataType:\"text\",success:function(data) {\n					data = eval(\"(\"+data+\")\");\n					if(page<=data.maxPage&&page>0){\n						_self.info =data.list;\n						_self.maxpage=data.maxPage;\n						_self.currentpage=page;\n						_self.flag=true;\n					}else if(page<=0){\n						_self.getData(1);\n					}else{\n						_self.getData(page-1);\n					}\n					_self.$nextTick(function(){\n						_self.initClickChecked();//业务需要方法，在dom加载结束后调用\n					})\n					}});\n			}}})\n\n```\n其中page-divide 就是定义的子组件。因为没有引用vue-resource,所以直接通过ajax得到数据，注意vue的this在ajax里面不能直接用，因为ajax里的this指的是调用本次ajax请求时传递的options参数。 el中使用v-for进行循环，循环次数为pagesize。在父组件中设置index,maxpage,curpage三个属性传入子组件。当子组件触发父组件switchpage方法时，父组件调用getData方法，重新获得数据。\n\n\n', '<p> 本方法利用vue的父子组件实现分页功能，UI来自bootstrap。实现效果是最大页数小于五时全部显示，分页只显示五个页数，具体页码显示范围根据当前页与最大页数来变换</p><!--more-->\n<p>一.介绍</p><pre><code>效果如下图所示：</code></pre><p><img src=\"/uploads/2019/02/02196667f88d740a0cb55cf1d2090e43.jpg\" alt=\"divide.jpg\">\n二.子组件部分</p><pre><code class=\"language-javaScript\">    Vue.component(<span class=\"hljs-string\">\'page-divide\'</span>,{\n        <span class=\"hljs-attr\">props</span>:[<span class=\"hljs-string\">\'index\'</span>,<span class=\"hljs-string\">\'maxpage\'</span>,<span class=\"hljs-string\">\'curpage\'</span>],\n        <span class=\"hljs-attr\">computed</span>:{\n            <span class=\"hljs-attr\">pagelist</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{    <span class=\"hljs-comment\">//控制页面显示页码范围的方法</span>\n                    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.maxpage&lt;<span class=\"hljs-number\">5</span>){\n                        <span class=\"hljs-keyword\">return</span>  <span class=\"hljs-keyword\">this</span>.index;\n                        }<span class=\"hljs-keyword\">else</span>{\n                            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.curpage<span class=\"hljs-number\">-2</span>&lt;=<span class=\"hljs-number\">0</span>){\n                                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.index;\n                            }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.curpage+<span class=\"hljs-number\">2</span>&gt;<span class=\"hljs-keyword\">this</span>.maxpage){\n                                 <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.maxpage+<span class=\"hljs-keyword\">this</span>.index<span class=\"hljs-number\">-5</span>;\n                            }<span class=\"hljs-keyword\">else</span>{\n                                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.curpage+<span class=\"hljs-keyword\">this</span>.index<span class=\"hljs-number\">-3</span>;\n                            }\n                        }\n            }\n        },\n        <span class=\"hljs-attr\">template</span>:<span class=\"hljs-string\">\'&lt;li v-bind:class=\"{active:curpage==pagelist}\"&gt;&lt;a  v-on:click=\"switchpage\"&gt;{{pagelist}}&lt;/a&gt;&lt;/li&gt;\'</span>,\n        <span class=\"hljs-attr\">methods</span>:{         \n            <span class=\"hljs-attr\">switchpage</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">\'switchpage\'</span>,<span class=\"hljs-keyword\">this</span>.pagelist);\n            }\n        }    \n    });\n</code></pre>\n<p>我们定义了一个标签名为page-divide的子组件由父组件传入三个属性，index:当前循环的下标,maxpage:最大页数,curpage:当前页面页码。子组件的属性pagelist,由根据computed计算得到，当前页等于pagelist时，模板的li标签样式变为active。点击模板中a标签，调用子组件switchpage方法，该方法触发父组件switchpage方法。\n二.父组件部分</p><pre><code>首先创建父组件的vm实例，\n\n 父组件使用Dom元素作为模板：</code></pre><pre><code class=\"language-html\">&lt;center&gt;\n    &lt;div id=\"page\" onselectstart=\"return false\"&gt;\n        &lt;nav aligh=\"center\" aria-lable=\"Page navigation\"&gt;\n            &lt;ul align=\"center\" id=\"pager\" class=\"pagination\"&gt;\n                &lt;li&gt;&lt;a v-on:click=\"getData(currentpage-1)\"&gt;上一页&lt;/a&gt;&lt;/li&gt;\n                &lt;page-divide @switchpage=\"getData\" \n                             v-for=\"n in pagesize\" \n                             :key=\"n.index\" \n                             :index=\"n\"\n                             :maxpage=\"maxpage\" \n                             :curpage=\"currentpage\"&gt;\n                &lt;/page-divide&gt;\n                &lt;li&gt;&lt;a @click=\"getData(currentpage+1)\"&gt;下一页&lt;/a&gt;&lt;/l&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    &lt;/div&gt;\n&lt;/center&gt;\n</code></pre>\n<p>vue实例:</p><pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">var</span> vmstand = <span class=\"hljs-keyword\">new</span> Vue({\n        <span class=\"hljs-attr\">el</span>:<span class=\"hljs-string\">\'#stand\'</span>,\n        <span class=\"hljs-attr\">data</span>:{\n            <span class=\"hljs-attr\">currentpage</span>:currentpage,\n            <span class=\"hljs-attr\">maxpage</span>:<span class=\"hljs-number\">0</span>\n        },<span class=\"hljs-attr\">computed</span>:{\n            <span class=\"hljs-attr\">pagesize</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.maxpage&gt;<span class=\"hljs-number\">5</span>?<span class=\"hljs-number\">5</span>:<span class=\"hljs-keyword\">this</span>.maxpage;\n            }\n            },\n        <span class=\"hljs-attr\">methods</span>:{\n            <span class=\"hljs-attr\">getData</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">page</span>)</span>{\n                <span class=\"hljs-keyword\">this</span>.currentpage=page;\n                <span class=\"hljs-keyword\">var</span> _self=<span class=\"hljs-keyword\">this</span>;\n                _self.flag=<span class=\"hljs-literal\">false</span>;\n                $.ajax({<span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">\"POST\"</span>,<span class=\"hljs-attr\">url</span>:<span class=\"hljs-string\">\"staticInfoController/getPage.do\"</span>,\n                    <span class=\"hljs-attr\">data</span> : {<span class=\"hljs-string\">\'pageSize\'</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\'currentPage\'</span>:page,<span class=\"hljs-string\">\'params\'</span>:<span class=\"hljs-keyword\">this</span>.condition,<span class=\"hljs-string\">\'type\'</span>:<span class=\"hljs-string\">\'basic.Standard\'</span>},<span class=\"hljs-attr\">async</span>:<span class=\"hljs-literal\">false</span>,\n                    <span class=\"hljs-attr\">dataType</span>:<span class=\"hljs-string\">\"text\"</span>,<span class=\"hljs-attr\">success</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>{\n                    data = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\"(\"</span>+data+<span class=\"hljs-string\">\")\"</span>);\n                    <span class=\"hljs-keyword\">if</span>(page&lt;=data.maxPage&amp;&amp;page&gt;<span class=\"hljs-number\">0</span>){\n                        _self.info =data.list;\n                        _self.maxpage=data.maxPage;\n                        _self.currentpage=page;\n                        _self.flag=<span class=\"hljs-literal\">true</span>;\n                    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(page&lt;=<span class=\"hljs-number\">0</span>){\n                        _self.getData(<span class=\"hljs-number\">1</span>);\n                    }<span class=\"hljs-keyword\">else</span>{\n                        _self.getData(page<span class=\"hljs-number\">-1</span>);\n                    }\n                    _self.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n                        _self.initClickChecked();<span class=\"hljs-comment\">//业务需要方法，在dom加载结束后调用</span>\n                    })\n                    }});\n            }}})\n</code></pre>\n<p>其中page-divide 就是定义的子组件。因为没有引用vue-resource,所以直接通过ajax得到数据，注意vue的this在ajax里面不能直接用，因为ajax里的this指的是调用本次ajax请求时传递的options参数。 el中使用v-for进行循环，循环次数为pagesize。在父组件中设置index,maxpage,curpage三个属性传入子组件。当子组件触发父组件switchpage方法时，父组件调用getData方法，重新获得数据。</p>', '2019-03-07 11:50:02', '2019-05-27 12:02:51', 0, '2019-05-27 12:02:51', 'Y', NULL);
INSERT INTO `sx_content` VALUES (33, '简单介绍前端MVC/MVVM模式特点及区别', 1, 'c94bf93ba4b6e7ee7a820fc2aeb83700', '/uploads/2019/05/4075f52a610bb38e824583af78064983.jpg', 1, 99, 'post', '<p> MVC,MVP,MVVM是三种常见的前端架构模式(Architectural Pattern),它通过分离关注点来改进代码组织方式。不同于设计模式(Design Pattern),只是为了解决一类问题而总结出的抽象方法，一种架构模式往往能使用多种设计模式。</p>', ' MVC,MVP,MVVM是三种常见的前端架构模式(Architectural Pattern),它通过分离关注点来改进代码组织方式。不同于设计模式(Design Pattern),只是为了解决一类问题而总结出的抽象方法，一种架构模式往往能使用多种设计模式。\n<!--more-->\n一.概述\nMVC模式是MVP,MVVM模式的基础，这两种模式更像是MVC模式的优化改良版,他们三个的MV即Model，view相同，不同的是MV之间的纽带部分。本文主要介绍MVC与MVVM的应用与区别，因为MVP好像不是很常用。\n 二.MVC\n\n    简介一下MVC：\n![mvc.jpg](/uploads/2019/02/67da12f0bc2b07a0f540b06b9287fbef.jpg)\nMVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\n\n    如果前端没有框架，只使用原生的html+js，MVC模式可以这样理解。将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n    按照上面这种方式分层，感觉多少有点强行MVC，因为Model层被弱化了。我们可以看看其他主流MVC框架是怎么分层的，拿BackBone举例。\n\n    首先简单介绍一下backbone，它是一个轻量级前端MVC框架，用于结构化管理页面中大量的js（就是管理大量js文件的项目更适用），建立与服务器，视图间的无缝连接，为构建复杂应用提供基础架构。backbone里面包含Model，View，Collection，Router等模块。这里的Model和View与MVC模式的Model和View有区别，我们先看Model。\n```javaScript\nvar M = Backbone.Model.extend({  \n\n　　defaults:{name:\"hello\"} ,\n\n　　initialize : function(){   //new M时，会执行这个初始化函数。\n\n　　　　this.on(\"change\",function(){   //监听change事件\n\n　　　　　　alert(1);\n\n　　　　})\n\n　　}\n\n})\n\nvar model = new M();\n\nmodel.set(\"name\",\"hi\");    //改变模型的name值时，就会触发change事件，弹出1.其实这里只要改变模型，就会触发。\n\n```\n这里Model的对象不只包含数据，也有对属性（name）的监听事件。所以backbone里的Model也不是纯Model，它有一部分Controller的功能。\n\n我们再看看Backbone的View\n```javaScript\nvar M = Backbone.Model.extend({  \n\n　　defaults:{name:\"hello\"} 　\n\n});\n\nvar V = Backbone.View.extend({  \n\n　　initialize:function(){   //new V时，会跟这个视图的model绑定change事件，回调方法是视图的show方法\n\n　　　　this.listenTo(this.model, \"change\", this.show);   //listenTo方法跟on一样是绑定事件的，但是listenTo可以设置this的指向，它多一个参数。它的意思就是：给this.model绑定change事件。\n\n　　},\n\n　　show:funtion(model){\n\n　　　　$(\"#tt\").append(this.model.name);\n\n　　}\n\n});\n\nvar m= new M();\n\nvar v = new V({model:m});\n\nm.set(\"name\",\"hi\");    //改变模型的name值时，就会触发change事件，在视图中弹出模型设置的name值。\n\n```\n这里view即包含了视图显示也包含了事件监听，属于传统的View+Model。\n\n    综上可以看出，backbone这样的MVC框架，Model和View的概念很突出，Controller主要放在了View里面。这种模式更好理解，Model看成模型，View看成这个模型的视图化体现，而Controller根据需要写在各自的方法里。这么一看MVC还是挺好的，那为什么有MVVM这种改良版本呢？\n\n    三.MVVM\n![mvc2.jpg](/uploads/2019/02/b26f9781c3c508ec286f2b10fdf6f515.jpg)\n\n    MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。非常的神奇~\n\n    这里我们拿典型的MVVM模式的代表，Vue，来举例\n```html\n<div id=\"app-5\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">逆转消息</button>\n</div>\n```\n```javaScript\nvar app5 = new Vue({\n  el: \'#app-5\',\n  data: {\n    message: \'Hello Vue.js!\'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split(\'\').reverse().join(\'\')\n    }\n  }\n})\n```\n这里的html部分相当于View层，可以看到这里的View通过通过模板语法来声明式的将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。\n\n    Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，即Model变化时VIew可以实时更新，View变化也能让Model发生变化。\n\n    整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性。\n\n    四.总结\n\n    在学习MVC与MVVM架构模式的过程中，经常会对分层的界限叫不准。比如说不清楚js里到底哪里算Model，哪里算Controller，Vue实例里面Model与ViewModel的严格界限在哪，有时候越想越感觉叫不准。当我从头到尾整理完这两种模式特点的时候，发现这个界限没有那么重要。我觉得重要的是，理解两种模式的基本思想，根据应用需求，选择适合自己业务的框架。MVVM自然有很多先进的地方，但有的项目选择BackBone可能会更适合。在实践中比较两种模式的各个框架的优缺点，选择适合自己的架构模式，更有利于项目的高效开发。\n', '<p> MVC,MVP,MVVM是三种常见的前端架构模式(Architectural Pattern),它通过分离关注点来改进代码组织方式。不同于设计模式(Design Pattern),只是为了解决一类问题而总结出的抽象方法，一种架构模式往往能使用多种设计模式。</p><!--more-->\n<p>一.概述\nMVC模式是MVP,MVVM模式的基础，这两种模式更像是MVC模式的优化改良版,他们三个的MV即Model，view相同，不同的是MV之间的纽带部分。本文主要介绍MVC与MVVM的应用与区别，因为MVP好像不是很常用。\n 二.MVC</p><pre><code>简介一下MVC：</code></pre><p><img src=\"/uploads/2019/02/67da12f0bc2b07a0f540b06b9287fbef.jpg\" alt=\"mvc.jpg\">\nMVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</p><pre><code>如果前端没有框架，只使用原生的html+js，MVC模式可以这样理解。将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n按照上面这种方式分层，感觉多少有点强行MVC，因为Model层被弱化了。我们可以看看其他主流MVC框架是怎么分层的，拿BackBone举例。\n\n首先简单介绍一下backbone，它是一个轻量级前端MVC框架，用于结构化管理页面中大量的js（就是管理大量js文件的项目更适用），建立与服务器，视图间的无缝连接，为构建复杂应用提供基础架构。backbone里面包含Model，View，Collection，Router等模块。这里的Model和View与MVC模式的Model和View有区别，我们先看Model。</code></pre><pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">var</span> M = Backbone.Model.extend({  \n\n　　<span class=\"hljs-attr\">defaults</span>:{<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">\"hello\"</span>} ,\n\n　　<span class=\"hljs-attr\">initialize</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{   <span class=\"hljs-comment\">//new M时，会执行这个初始化函数。</span>\n\n　　　　<span class=\"hljs-keyword\">this</span>.on(<span class=\"hljs-string\">\"change\"</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{   <span class=\"hljs-comment\">//监听change事件</span>\n\n　　　　　　alert(<span class=\"hljs-number\">1</span>);\n\n　　　　})\n\n　　}\n\n})\n\n<span class=\"hljs-keyword\">var</span> model = <span class=\"hljs-keyword\">new</span> M();\n\nmodel.set(<span class=\"hljs-string\">\"name\"</span>,<span class=\"hljs-string\">\"hi\"</span>);    <span class=\"hljs-comment\">//改变模型的name值时，就会触发change事件，弹出1.其实这里只要改变模型，就会触发。</span>\n</code></pre>\n<p>这里Model的对象不只包含数据，也有对属性（name）的监听事件。所以backbone里的Model也不是纯Model，它有一部分Controller的功能。</p><p>我们再看看Backbone的View</p><pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">var</span> M = Backbone.Model.extend({  \n\n　　<span class=\"hljs-attr\">defaults</span>:{<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">\"hello\"</span>} 　\n\n});\n\n<span class=\"hljs-keyword\">var</span> V = Backbone.View.extend({  \n\n　　<span class=\"hljs-attr\">initialize</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{   <span class=\"hljs-comment\">//new V时，会跟这个视图的model绑定change事件，回调方法是视图的show方法</span>\n\n　　　　<span class=\"hljs-keyword\">this</span>.listenTo(<span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-string\">\"change\"</span>, <span class=\"hljs-keyword\">this</span>.show);   <span class=\"hljs-comment\">//listenTo方法跟on一样是绑定事件的，但是listenTo可以设置this的指向，它多一个参数。它的意思就是：给this.model绑定change事件。</span>\n\n　　},\n\n　　<span class=\"hljs-attr\">show</span>:funtion(model){\n\n　　　　$(<span class=\"hljs-string\">\"#tt\"</span>).append(<span class=\"hljs-keyword\">this</span>.model.name);\n\n　　}\n\n});\n\n<span class=\"hljs-keyword\">var</span> m= <span class=\"hljs-keyword\">new</span> M();\n\n<span class=\"hljs-keyword\">var</span> v = <span class=\"hljs-keyword\">new</span> V({<span class=\"hljs-attr\">model</span>:m});\n\nm.set(<span class=\"hljs-string\">\"name\"</span>,<span class=\"hljs-string\">\"hi\"</span>);    <span class=\"hljs-comment\">//改变模型的name值时，就会触发change事件，在视图中弹出模型设置的name值。</span>\n</code></pre>\n<p>这里view即包含了视图显示也包含了事件监听，属于传统的View+Model。</p><pre><code>综上可以看出，<span class=\"hljs-selector-tag\">backbone</span>这样的<span class=\"hljs-selector-tag\">MVC</span>框架，<span class=\"hljs-selector-tag\">Model</span>和<span class=\"hljs-selector-tag\">View</span>的概念很突出，<span class=\"hljs-selector-tag\">Controller</span>主要放在了<span class=\"hljs-selector-tag\">View</span>里面。这种模式更好理解，<span class=\"hljs-selector-tag\">Model</span>看成模型，<span class=\"hljs-selector-tag\">View</span>看成这个模型的视图化体现，而<span class=\"hljs-selector-tag\">Controller</span>根据需要写在各自的方法里。这么一看<span class=\"hljs-selector-tag\">MVC</span>还是挺好的，那为什么有<span class=\"hljs-selector-tag\">MVVM</span>这种改良版本呢？\n\n三<span class=\"hljs-selector-class\">.MVVM</span></code></pre><p><img src=\"/uploads/2019/02/b26f9781c3c508ec286f2b10fdf6f515.jpg\" alt=\"mvc2.jpg\"></p><pre><code>MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。非常的神奇~\n\n这里我们拿典型的MVVM模式的代表，Vue，来举例</code></pre><pre><code class=\"language-html\">&lt;div id=\"app-5\"&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;button v-on:click=\"reverseMessage\"&gt;逆转消息&lt;/button&gt;\n&lt;/div&gt;</code></pre>\n<pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">var</span> app5 = <span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app-5\'</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue.js!\'</span>\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    <span class=\"hljs-attr\">reverseMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-keyword\">this</span>.message.split(<span class=\"hljs-string\">\'\'</span>).reverse().join(<span class=\"hljs-string\">\'\'</span>)\n    }\n  }\n})</code></pre>\n<p>这里的html部分相当于View层，可以看到这里的View通过通过模板语法来声明式的将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。</p><pre><code>Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，即Model变化时VIew可以实时更新，View变化也能让Model发生变化。\n\n整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性。\n\n四.总结\n\n在学习MVC与MVVM架构模式的过程中，经常会对分层的界限叫不准。比如说不清楚js里到底哪里算Model，哪里算Controller，Vue实例里面Model与ViewModel的严格界限在哪，有时候越想越感觉叫不准。当我从头到尾整理完这两种模式特点的时候，发现这个界限没有那么重要。我觉得重要的是，理解两种模式的基本思想，根据应用需求，选择适合自己业务的框架。MVVM自然有很多先进的地方，但有的项目选择BackBone可能会更适合。在实践中比较两种模式的各个框架的优缺点，选择适合自己的架构模式，更有利于项目的高效开发。</code></pre>', '2019-05-10 11:50:08', '2019-05-27 12:02:14', 9, '2019-05-27 12:02:14', 'Y', NULL);
INSERT INTO `sx_content` VALUES (34, 'nodeJs实现文件上传，下载，删除', 1, '6a687ea35cc35424abd7acbed4776b5d', '/uploads/2019/05/c9f0e876e87442d8830bbebd9b992290.jpg', 1, 99, 'post', '<p>本文介绍了nodeJs+express框架下，用multer中间件实现文件的上传下载以及删除</p>', '本文介绍了nodeJs+express框架下，用multer中间件实现文件的上传下载以及删除\n<!--more-->\n一.上传\n\n     前端使用ElementUI的upload组件实现上传，代码如下：\n```html\n    <el-upload\n      class=\"upload-demo\"\n      action=\"http://localhost:9010/table/uploadFile\"\n      :on-preview=\"handlePreview\"\n      :on-remove=\"handleRemove\"\n      :before-remove=\"beforeRemove\"\n      multiple\n      :limit=\"3\"\n      :on-exceed=\"handleExceed\"\n      :file-list=\"fileList\" ref=\"elupload\">\n      <el-button size=\"small\" type=\"primary\">点击上传</el-button>\n      <div slot=\"tip\" class=\"el-upload__tip\">只能上传jpg/png文件，且不超过500kb</div>\n    </el-upload>\n```\naction定义后台接口的地址，后台代码如下：\n```javascirpt\nvar multer = require(\'multer\');//引入multer\nvar upload = multer({dest: \'uploads/\'});//设置上传文件存储地址\nrouter.post(\'/uploadFile\', upload.single(\'file\'), (req, res, next) => {\n\n    let ret = {};\n    ret[\'code\'] = 20000;\n    var file = req.file;\n    if (file) {\n        var fileNameArr = file.originalname.split(\'.\');\n        var suffix = fileNameArr[fileNameArr.length - 1];\n        //文件重命名\n        fs.renameSync(\'./uploads/\' + file.filename, `./uploads/${file.filename}.${suffix}`);\n        file[\'newfilename\'] = `${file.filename}.${suffix}`;\n    }\n    ret[\'file\'] = file;\n    res.send(ret);\n})\n```\n定义好上传路径，选择好文件走后台方法时，文件已经下载到后端项目uploads文件夹。文件名是自动生成的uuid。代码需要做的是把文件的后缀加到上传的文件里。\n\n这里是上传一个文件，所以用upload.single(\'file\')，传入的参数是前台input type=file的name值。\nmulter详细API [在这里](https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md)。\n三.下载\n\n    后端代码：\n```javaScript\nrouter.use(\'/downloadFile\', (req, res, next) => {\n    var filename = req.query.filename;\n    var oldname = req.query.oldname;\n    var file = \'./uploads/\' + filename;\n    res.writeHead(200, {\n        \'Content-Type\': \'application/octet-stream\',//告诉浏览器这是一个二进制文件\n        \'Content-Disposition\': \'attachment; filename=\' + encodeURI(oldname),//告诉浏览器这是一个需要下载的文件\n    });//设置响应头\n    var readStream = fs.createReadStream(file);//得到文件输入流\n    debugger\n    readStream.on(\'data\', (chunk) => {\n        res.write(chunk, \'binary\');//文档内容以二进制的格式写到response的输出流\n    });\n    readStream.on(\'end\', () => {\n        res.end();\n    })\n})\n```\n 前台传入文件名，后台拼出来文件下载的相对路径。根据路径得到文件输入流，并把内容以二进制格式写到response的输出流。读取结束后响应回浏览器。\n\n前端代码\n```javaScript\nconst downloadUrl = url => {\n  let iframe = document.createElement(\'iframe\');\n  iframe.style.display = \'none\'\n  iframe.src = url\n  iframe.onload = function () {\n    document.body.removeChild(iframe)\n  }\n  document.body.appendChild(iframe)\n};\nmodule.exports=downloadUrl;\n```\n  创建一个工具方法，传入后台接口路径，执行下载。\n```javaScript\ndowloadUtil(`${process.env.BASE_API}/table/downloadFile?filename=${filename}&oldname=${oldname}`);\n```\n四.删除\n```javaScript\nfs.unlinkSync(\'./uploads/\' + filename);\n```\n调用fs模块的unlinkSync方法，传入文件路径，直接删除。也可以用fs.unlink(callback)这个异步删除。\n\n\n\n\n\n\n\n', '<p>本文介绍了nodeJs+express框架下，用multer中间件实现文件的上传下载以及删除</p><!--more-->\n<p>一.上传</p><pre><code> 前端使用ElementUI的upload组件实现上传，代码如下：</code></pre><pre><code class=\"language-html\">    &lt;el-upload\n      <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"upload-demo\"</span>\n      action=<span class=\"hljs-string\">\"http://localhost:9010/table/uploadFile\"</span>\n      :on-preview=<span class=\"hljs-string\">\"handlePreview\"</span>\n      :on-remove=<span class=\"hljs-string\">\"handleRemove\"</span>\n      :before-remove=<span class=\"hljs-string\">\"beforeRemove\"</span>\n      multiple\n      :limit=<span class=\"hljs-string\">\"3\"</span>\n      :on-exceed=<span class=\"hljs-string\">\"handleExceed\"</span>\n      :file-list=<span class=\"hljs-string\">\"fileList\"</span> ref=<span class=\"hljs-string\">\"elupload\"</span>&gt;\n      &lt;el-button size=\"small\" type=\"primary\"&gt;点击上传&lt;/el-button&gt;\n      &lt;div slot=\"tip\" class=\"el-upload__tip\"&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;\n    &lt;/el-upload&gt;</code></pre>\n<p>action定义后台接口的地址，后台代码如下：</p><pre><code class=\"language-javascirpt\"><span class=\"hljs-keyword\">var</span> multer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'multer\'</span>);<span class=\"hljs-comment\">//引入multer</span>\n<span class=\"hljs-keyword\">var</span> upload = multer({dest: <span class=\"hljs-string\">\'uploads/\'</span>});<span class=\"hljs-comment\">//设置上传文件存储地址</span>\nrouter.post(<span class=\"hljs-string\">\'/uploadFile\'</span>, upload.single(<span class=\"hljs-string\">\'file\'</span>), <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =&gt;</span> {\n\n    <span class=\"hljs-keyword\">let</span> ret = {};\n    ret[<span class=\"hljs-string\">\'code\'</span>] = <span class=\"hljs-number\">20000</span>;\n    <span class=\"hljs-keyword\">var</span> file = req.file;\n    <span class=\"hljs-keyword\">if</span> (file) {\n        <span class=\"hljs-keyword\">var</span> fileNameArr = file.originalname.split(<span class=\"hljs-string\">\'.\'</span>);\n        <span class=\"hljs-keyword\">var</span> suffix = fileNameArr[fileNameArr.length - <span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-comment\">//文件重命名</span>\n        fs.renameSync(<span class=\"hljs-string\">\'./uploads/\'</span> + file.filename, <span class=\"hljs-string\">`./uploads/<span class=\"hljs-subst\">${file.filename}</span>.<span class=\"hljs-subst\">${suffix}</span>`</span>);\n        file[<span class=\"hljs-string\">\'newfilename\'</span>] = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${file.filename}</span>.<span class=\"hljs-subst\">${suffix}</span>`</span>;\n    }\n    ret[<span class=\"hljs-string\">\'file\'</span>] = file;\n    res.send(ret);\n})</code></pre>\n<p>定义好上传路径，选择好文件走后台方法时，文件已经下载到后端项目uploads文件夹。文件名是自动生成的uuid。代码需要做的是把文件的后缀加到上传的文件里。</p><p>这里是上传一个文件，所以用upload.single(&#39;file&#39;)，传入的参数是前台input type=file的name值。\nmulter详细API <a href=https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md\n      title=https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md\n      target=\'_blank\'\n      }>在这里</a>。\n三.下载</p><pre><code>后端代码：</code></pre><pre><code class=\"language-javaScript\">router.use(<span class=\"hljs-string\">\'/downloadFile\'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">var</span> filename = req.query.filename;\n    <span class=\"hljs-keyword\">var</span> oldname = req.query.oldname;\n    <span class=\"hljs-keyword\">var</span> file = <span class=\"hljs-string\">\'./uploads/\'</span> + filename;\n    res.writeHead(<span class=\"hljs-number\">200</span>, {\n        <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/octet-stream\'</span>,<span class=\"hljs-comment\">//告诉浏览器这是一个二进制文件</span>\n        <span class=\"hljs-string\">\'Content-Disposition\'</span>: <span class=\"hljs-string\">\'attachment; filename=\'</span> + <span class=\"hljs-built_in\">encodeURI</span>(oldname),<span class=\"hljs-comment\">//告诉浏览器这是一个需要下载的文件</span>\n    });<span class=\"hljs-comment\">//设置响应头</span>\n    <span class=\"hljs-keyword\">var</span> readStream = fs.createReadStream(file);<span class=\"hljs-comment\">//得到文件输入流</span>\n    debugger\n    readStream.on(<span class=\"hljs-string\">\'data\'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">chunk</span>) =&gt;</span> {\n        res.write(chunk, <span class=\"hljs-string\">\'binary\'</span>);<span class=\"hljs-comment\">//文档内容以二进制的格式写到response的输出流</span>\n    });\n    readStream.on(<span class=\"hljs-string\">\'end\'</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        res.end();\n    })\n})</code></pre>\n<p> 前台传入文件名，后台拼出来文件下载的相对路径。根据路径得到文件输入流，并把内容以二进制格式写到response的输出流。读取结束后响应回浏览器。</p><p>前端代码</p><pre><code class=\"language-javaScript\"><span class=\"hljs-keyword\">const</span> downloadUrl = <span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> iframe = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">\'iframe\'</span>);\n  iframe.style.display = <span class=\"hljs-string\">\'none\'</span>\n  iframe.src = url\n  iframe.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">document</span>.body.removeChild(iframe)\n  }\n  <span class=\"hljs-built_in\">document</span>.body.appendChild(iframe)\n};\n<span class=\"hljs-built_in\">module</span>.exports=downloadUrl;</code></pre>\n<p>  创建一个工具方法，传入后台接口路径，执行下载。</p><pre><code class=\"language-javaScript\">dowloadUtil(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${process.env.BASE_API}</span>/table/downloadFile?filename=<span class=\"hljs-subst\">${filename}</span>&amp;oldname=<span class=\"hljs-subst\">${oldname}</span>`</span>);</code></pre>\n<p>四.删除</p><pre><code class=\"language-javaScript\"><span class=\"hljs-selector-tag\">fs</span><span class=\"hljs-selector-class\">.unlinkSync</span>(<span class=\"hljs-string\">\'./uploads/\'</span> + filename);</code></pre>\n<p>调用fs模块的unlinkSync方法，传入文件路径，直接删除。也可以用fs.unlink(callback)这个异步删除。</p>', '2019-05-29 11:47:19', '2019-05-30 19:24:58', 2, '2019-05-30 19:24:58', 'N', NULL);
INSERT INTO `sx_content` VALUES (35, 'Vue+thinkJs博客网站（一）之vue多页面应用的webpack3配置', 1, '6cf0d61cdd3e8bc38d249586ab602260', '/uploads/2019/05/d0224b80e374c6a88de1dcafee306d59.jpg', 1, 99, 'post', '<p>本项目使用vue作为前端框架，thinkJs作为后端框架，构建个人博客网站，页面分为博客展示和后台管理，主要目的是学习使用thinkJs。现在只完成了主要的博客增删改功能，发现webpack的配置遇到了一些坑，这里先记录下</p>', '本项目使用vue作为前端框架，thinkJs作为后端框架，构建个人博客网站，页面分为博客展示和后台管理，主要目的是学习使用thinkJs。现在只完成了主要的博客增删改功能，发现webpack的配置遇到了一些坑，这里先记录下\n<!--more-->\n一.项目简介\n其中system文件夹是前端vue项目的代码，博客展示页面与后台管理页面都在这里，打包成两个页面，具体webpack配置是本文重点。[项目github地址点这里。](https://github.com/sunxing102005/self_blog)\n![20190131151830192.png](/uploads/2019/02/932229ba974a65ebd5bd6e99e7b9a32e.png)\n二.搭建过程\n\n安装nodejs后，首先安装thinkjs\n```text\nnpm install -g think-cli;\nthinkjs new self_blog;\nnpm install;\nnpm start;\n```\n这样thinkJs项目初步搭建完成了，接下来创建vue项目。项目根目录下新建文件夹system。\n```text\nnpm install -g vue-cli\nvue init webpack self_blog\ncd self_blog\nnpm install\nnpm run dev\n```\n这样vue项目初步搭建完毕，接下来讲下这里vue的具体webpack配置。\n三.webpack配置\n\n项目前端页面分为博客的展示和后台管理，这里的思路是将sytem的src下面放后台管理页面，在sytem下新建blog文件夹，放前台展示页面，打包时生成两个html，实现webpack打包多页面应用。目录如下：\n![20190131155206252.png](/uploads/2019/02/f7bbe9e50ef127388018790cc61fed2f.png)\n\n1.webpack.base.conf.js的配置\n\n使用vue-cli创建项目，npm run dev运行开发环境，会使用webpack-dev-server作为前端服务器，从而实现热加载。这样打包的文件只会在内存里，这里我的思路是直接生成到thinkJs项目的view目录下，通过服务端的路由返回给前端。这样只用启动后端的服务就行了，因为文件已经打包到服务端，前端也不存在跨域访问后端的问题了。所以这里就不需要配置devServer了，而是改变html与js等静态资源的生成目录。首先看下webpack.base.conf.js的代码：\n\n```javaScript\n\"use strict\";\nconst path = require(\"path\");\nconst utils = require(\"./utils\");\nconst config = require(\"../config\");\nconst vueLoaderConfig = require(\"./vue-loader.conf\");\nconst webpack = require(\"webpack\");\nconst baseFileName = require(\"../package.json\").name;\nconst ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nconst cleanWebpackPlugin = require(\"clean-webpack-plugin\");\nconst AssetsPlugin = require(\"assets-webpack-plugin\");\nfunction resolve(dir) {\n  return path.join(__dirname, \"..\", dir);\n}\n\nmodule.exports = {\n  context: path.resolve(__dirname, \"../\"),\n  entry: {\n    app: \"./src/main.js\",\n    blog: \"./blog/index.js\"\n  },\n  output: {\n    path: config.build.assetsRoot,\n    filename: \"[name].js\",\n    publicPath:\n      process.env.NODE_ENV === \"production\"\n        ? config.build.assetsPublicPath\n        : config.dev.assetsPublicPath\n  },\n  resolve: {\n    extensions: [\".js\", \".vue\", \".json\"],\n    alias: {\n      vue$: \"vue/dist/vue.esm.js\",\n      \"@\": resolve(\"src\")\n    }\n  },\n  externals: {\n    vue: \"Vue\",\n    \"vue-router\": \"VueRouter\",\n    echarts: \"echarts\",\n    ElementUI: \"element-ui\"\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: \"vue-loader\",\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: \"babel-loader\",\n        include: [\n          resolve(\"src\"),\n          resolve(\"test\"),\n          resolve(\"node_modules/webpack-dev-server/client\")\n        ]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: \"url-loader\",\n        exclude: [resolve(\"src/icons\")],\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(baseFileName + \"/img/[name].[hash:7].[ext]\")\n        }\n      },\n      {\n        test: /\\.svg$/,\n        loader: \"svg-sprite-loader\",\n        include: [resolve(\"src\")],\n        options: {\n          symbolId: \"icon-[name]\"\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: \"url-loader\",\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(baseFileName + \"/media/[name].[hash:7].[ext]\")\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: \"url-loader\",\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(baseFileName + \"/fonts/[name].[hash:7].[ext]\")\n        }\n      }\n    ]\n  },\n  plugins: [\n    new AssetsPlugin({\n      filename: \"build/webpack.assets.js\",\n      processOutput: function(assets) {\n        return \"window.WEBPACK_ASSETS=\" + JSON.stringify(assets);\n      }\n    }),\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \"vendor\",\n      minChunks: function(module) {\n        return (\n          module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(path.join(__dirname, \"../node_modules\")) === 0\n        );\n      }\n    }),\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \"manifest\",\n      minChunks: Infinity\n    }),\n    new ExtractTextPlugin({\n      filename: utils.assetsPath(\n        baseFileName + \"/css/[name].[contenthash].css\"\n      ),\n      allChunks: true\n    }),\n    // 编译前删除之前编译生成的静态资源\n    new cleanWebpackPlugin([\"www/static/self_blog\", \"view/blog\"], {\n      root: resolve(\"../\")\n    })\n  ],\n  node: {\n    setImmediate: false,\n    dgram: \"empty\",\n    fs: \"empty\",\n    net: \"empty\",\n    tls: \"empty\",\n    child_process: \"empty\"\n  }\n};\n\n```\n首先需要改的是入口文件，因为是多页面应用，需要多个入口文件来保证打包成不同的chunk。我们知道正常vue-cli创建的但页面应用，会打包成三个chunk，分别是vendor.js（第三方依赖），manifest.js（异步加载的实现），app.js（业务代码）。这里新增一个入口文件，打包时就会生成名为blog.js的chunk，含有前台展示页面的js业务代码。\n\n这里新增使用的clean-webpack-plugin，是为了每次编译后，删除之前生成的js，css等静态资源，否则因为这些资源不重名，就会一直堆在你生成的目录下。\n\n此外一些第三方依赖，vue,elementUI什么的，我使用了cdn引入，这样打包时这些依赖不会打进去，进而减小的vendor.js的体积。具体做法就是配置里的externals定义这些依赖，然后在生成html的模板里用script标签直接引入cdn里的js。\n\n注意一下，如果你开发时想用vue-devtool，需要引入vue.js，如果不用就引入vue.min.js。\n\n2.webpack.dev.conf.js的配置\n\n先看下代码：\n```javaScript\n\"use strict\";\nconst utils = require(\"./utils\");\nconst webpack = require(\"webpack\");\nconst config = require(\"../config\");\nconst merge = require(\"webpack-merge\");\nconst path = require(\"path\");\nconst baseWebpackConfig = require(\"./webpack.base.conf\");\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst FriendlyErrorsPlugin = require(\"friendly-errors-webpack-plugin\");\nconst portfinder = require(\"portfinder\");\n\nconst HOST = process.env.HOST;\nconst PORT = process.env.PORT && Number(process.env.PORT);\nconst baseFileName = require(\"../package.json\").name;\nfunction resolve(dir) {\n  return path.join(__dirname, \"..\", dir);\n}\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.dev.cssSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  // cheap-module-eval-source-map is faster for development\n  devtool: config.dev.devtool,\n  output: {\n    path: resolve(config.dev.assetsRoot),\n    filename: \"static/\" + baseFileName + \"/js/[name]-[hash:5].js\",\n    chunkFilename: \"static/\" + baseFileName + \"/js/[name]-[id:5].js\"\n  },\n\n  plugins: [\n    new webpack.DefinePlugin({\n      \"process.env\": require(\"../config/dev.env\")\n    }),\n    // new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: resolve(`../view/blog/index_index.html`),\n      template: \"./view/index.html\",\n      title: \"博客管理系统\",\n      favicon: resolve(\"favicon.ico\"),\n      inject: true,\n      chunks: [\"manifest\", \"vendor\", \"app\"]\n    }),\n    new HtmlWebpackPlugin({\n      filename: resolve(`../view/blog/blog_index.html`),\n      template: \"./view/blog.html\",\n      title: \"博客展示\",\n      inject: true,\n      chunks: [\"manifest\", \"vendor\", \"blog\"]\n    }),\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, \"../static\"),\n        to: config.dev.assetsSubDirectory,\n        ignore: [\".*\"]\n      }\n    ])\n  ]\n});\nmodule.exports = devWebpackConfig;\n```\n这里我删掉了之前默认配置的devSever，以及module.exports直接导出devWebpackConfig。此外，因为打包生成目录的变化，我修改了output里面的path,filename,chunkFilename。使他们生成到self_blog根目录的www/static下面，这也是thinkJs静态资源的默认目录。需要注意下，filename指的是你的出口文件（app），以及通过codespliting生成的js（vendor,manifest）的文件名；chunkFilename定义的是一些懒加载组件打包后的js文件名。\n\n下面需要添加的就是html-webpack-plugin，因为需要打包成两个html，所以使用两次这个插件。除了定义生成文件名（filename），html模板（template）等，还需要定义你这个html需要的chunk，这是跟单页面配置的一个区别。\n\n除此之外，如果你想要开发环境打包时就分离出css，那么在使用utils.styleLoaders时，将extract置为true。因为这里的方法判断是开发环境才使用extract-text-plugin抽离css。\n\n四.总结\n\n这个项目还没有部署，所以就先不讲webpack.prod.config.js的东西了，我先改了一版，具体可以看github上的代码。本次项目主要目的是练习thinkJs，这里先把前期webpack配置方面的东西简单说下，下一篇将会仔细讲下thinkJs的使用方法和特性。项目会继续更新，不少东西还没做完呢。\n\n', '<p>本项目使用vue作为前端框架，thinkJs作为后端框架，构建个人博客网站，页面分为博客展示和后台管理，主要目的是学习使用thinkJs。现在只完成了主要的博客增删改功能，发现webpack的配置遇到了一些坑，这里先记录下</p><!--more-->\n<p>一.项目简介\n其中system文件夹是前端vue项目的代码，博客展示页面与后台管理页面都在这里，打包成两个页面，具体webpack配置是本文重点。<a href=https://github.com/sunxing102005/self_blog\n      title=https://github.com/sunxing102005/self_blog\n      target=\'_blank\'\n      }>项目github地址点这里。</a>\n<img src=\"/uploads/2019/02/932229ba974a65ebd5bd6e99e7b9a32e.png\" alt=\"20190131151830192.png\">\n二.搭建过程</p><p>安装nodejs后，首先安装thinkjs</p><pre><code class=\"language-text\">npm install -g think-cli;\nthinkjs <span class=\"hljs-keyword\">new</span> self_blog;\nnpm install;\nnpm start;</code></pre>\n<p>这样thinkJs项目初步搭建完成了，接下来创建vue项目。项目根目录下新建文件夹system。</p><pre><code class=\"language-text\">npm install -g vue-cli\nvue init webpack self_blog\ncd self_blog\nnpm install\nnpm run dev</code></pre>\n<p>这样vue项目初步搭建完毕，接下来讲下这里vue的具体webpack配置。\n三.webpack配置</p><p>项目前端页面分为博客的展示和后台管理，这里的思路是将sytem的src下面放后台管理页面，在sytem下新建blog文件夹，放前台展示页面，打包时生成两个html，实现webpack打包多页面应用。目录如下：\n<img src=\"/uploads/2019/02/f7bbe9e50ef127388018790cc61fed2f.png\" alt=\"20190131155206252.png\"></p><p>1.webpack.base.conf.js的配置</p><p>使用vue-cli创建项目，npm run dev运行开发环境，会使用webpack-dev-server作为前端服务器，从而实现热加载。这样打包的文件只会在内存里，这里我的思路是直接生成到thinkJs项目的view目录下，通过服务端的路由返回给前端。这样只用启动后端的服务就行了，因为文件已经打包到服务端，前端也不存在跨域访问后端的问题了。所以这里就不需要配置devServer了，而是改变html与js等静态资源的生成目录。首先看下webpack.base.conf.js的代码：</p><pre><code class=\"language-javaScript\"><span class=\"hljs-meta\">\"use strict\"</span>;\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"path\"</span>);\n<span class=\"hljs-keyword\">const</span> utils = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./utils\"</span>);\n<span class=\"hljs-keyword\">const</span> config = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../config\"</span>);\n<span class=\"hljs-keyword\">const</span> vueLoaderConfig = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./vue-loader.conf\"</span>);\n<span class=\"hljs-keyword\">const</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"webpack\"</span>);\n<span class=\"hljs-keyword\">const</span> baseFileName = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../package.json\"</span>).name;\n<span class=\"hljs-keyword\">const</span> ExtractTextPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"extract-text-webpack-plugin\"</span>);\n<span class=\"hljs-keyword\">const</span> cleanWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"clean-webpack-plugin\"</span>);\n<span class=\"hljs-keyword\">const</span> AssetsPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"assets-webpack-plugin\"</span>);\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">dir</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> path.join(__dirname, <span class=\"hljs-string\">\"..\"</span>, dir);\n}\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">context</span>: path.resolve(__dirname, <span class=\"hljs-string\">\"../\"</span>),\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">app</span>: <span class=\"hljs-string\">\"./src/main.js\"</span>,\n    <span class=\"hljs-attr\">blog</span>: <span class=\"hljs-string\">\"./blog/index.js\"</span>\n  },\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">path</span>: config.build.assetsRoot,\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">\"[name].js\"</span>,\n    <span class=\"hljs-attr\">publicPath</span>:\n      process.env.NODE_ENV === <span class=\"hljs-string\">\"production\"</span>\n        ? config.build.assetsPublicPath\n        : config.dev.assetsPublicPath\n  },\n  <span class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">\".js\"</span>, <span class=\"hljs-string\">\".vue\"</span>, <span class=\"hljs-string\">\".json\"</span>],\n    <span class=\"hljs-attr\">alias</span>: {\n      <span class=\"hljs-attr\">vue$</span>: <span class=\"hljs-string\">\"vue/dist/vue.esm.js\"</span>,\n      <span class=\"hljs-string\">\"@\"</span>: resolve(<span class=\"hljs-string\">\"src\"</span>)\n    }\n  },\n  <span class=\"hljs-attr\">externals</span>: {\n    <span class=\"hljs-attr\">vue</span>: <span class=\"hljs-string\">\"Vue\"</span>,\n    <span class=\"hljs-string\">\"vue-router\"</span>: <span class=\"hljs-string\">\"VueRouter\"</span>,\n    <span class=\"hljs-attr\">echarts</span>: <span class=\"hljs-string\">\"echarts\"</span>,\n    <span class=\"hljs-attr\">ElementUI</span>: <span class=\"hljs-string\">\"element-ui\"</span>\n  },\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.vue$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"vue-loader\"</span>,\n        <span class=\"hljs-attr\">options</span>: vueLoaderConfig\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.js$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"babel-loader\"</span>,\n        <span class=\"hljs-attr\">include</span>: [\n          resolve(<span class=\"hljs-string\">\"src\"</span>),\n          resolve(<span class=\"hljs-string\">\"test\"</span>),\n          resolve(<span class=\"hljs-string\">\"node_modules/webpack-dev-server/client\"</span>)\n        ]\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(png|jpe?g|gif|svg)(\\?.*)?$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"url-loader\"</span>,\n        <span class=\"hljs-attr\">exclude</span>: [resolve(<span class=\"hljs-string\">\"src/icons\"</span>)],\n        <span class=\"hljs-attr\">options</span>: {\n          <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">10000</span>,\n          <span class=\"hljs-attr\">name</span>: utils.assetsPath(baseFileName + <span class=\"hljs-string\">\"/img/[name].[hash:7].[ext]\"</span>)\n        }\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.svg$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"svg-sprite-loader\"</span>,\n        <span class=\"hljs-attr\">include</span>: [resolve(<span class=\"hljs-string\">\"src\"</span>)],\n        <span class=\"hljs-attr\">options</span>: {\n          <span class=\"hljs-attr\">symbolId</span>: <span class=\"hljs-string\">\"icon-[name]\"</span>\n        }\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"url-loader\"</span>,\n        <span class=\"hljs-attr\">options</span>: {\n          <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">10000</span>,\n          <span class=\"hljs-attr\">name</span>: utils.assetsPath(baseFileName + <span class=\"hljs-string\">\"/media/[name].[hash:7].[ext]\"</span>)\n        }\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(woff2?|eot|ttf|otf)(\\?.*)?$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"url-loader\"</span>,\n        <span class=\"hljs-attr\">options</span>: {\n          <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">10000</span>,\n          <span class=\"hljs-attr\">name</span>: utils.assetsPath(baseFileName + <span class=\"hljs-string\">\"/fonts/[name].[hash:7].[ext]\"</span>)\n        }\n      }\n    ]\n  },\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-keyword\">new</span> AssetsPlugin({\n      <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">\"build/webpack.assets.js\"</span>,\n      <span class=\"hljs-attr\">processOutput</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">assets</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"window.WEBPACK_ASSETS=\"</span> + <span class=\"hljs-built_in\">JSON</span>.stringify(assets);\n      }\n    }),\n    <span class=\"hljs-keyword\">new</span> webpack.optimize.CommonsChunkPlugin({\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"vendor\"</span>,\n      <span class=\"hljs-attr\">minChunks</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">module</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> (\n          <span class=\"hljs-built_in\">module</span>.resource &amp;&amp;\n          <span class=\"hljs-regexp\">/\\.js$/</span>.test(<span class=\"hljs-built_in\">module</span>.resource) &amp;&amp;\n          <span class=\"hljs-built_in\">module</span>.resource.indexOf(path.join(__dirname, <span class=\"hljs-string\">\"../node_modules\"</span>)) === <span class=\"hljs-number\">0</span>\n        );\n      }\n    }),\n    <span class=\"hljs-keyword\">new</span> webpack.optimize.CommonsChunkPlugin({\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"manifest\"</span>,\n      <span class=\"hljs-attr\">minChunks</span>: <span class=\"hljs-literal\">Infinity</span>\n    }),\n    <span class=\"hljs-keyword\">new</span> ExtractTextPlugin({\n      <span class=\"hljs-attr\">filename</span>: utils.assetsPath(\n        baseFileName + <span class=\"hljs-string\">\"/css/[name].[contenthash].css\"</span>\n      ),\n      <span class=\"hljs-attr\">allChunks</span>: <span class=\"hljs-literal\">true</span>\n    }),\n    <span class=\"hljs-comment\">// 编译前删除之前编译生成的静态资源</span>\n    <span class=\"hljs-keyword\">new</span> cleanWebpackPlugin([<span class=\"hljs-string\">\"www/static/self_blog\"</span>, <span class=\"hljs-string\">\"view/blog\"</span>], {\n      <span class=\"hljs-attr\">root</span>: resolve(<span class=\"hljs-string\">\"../\"</span>)\n    })\n  ],\n  <span class=\"hljs-attr\">node</span>: {\n    <span class=\"hljs-attr\">setImmediate</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">dgram</span>: <span class=\"hljs-string\">\"empty\"</span>,\n    <span class=\"hljs-attr\">fs</span>: <span class=\"hljs-string\">\"empty\"</span>,\n    <span class=\"hljs-attr\">net</span>: <span class=\"hljs-string\">\"empty\"</span>,\n    <span class=\"hljs-attr\">tls</span>: <span class=\"hljs-string\">\"empty\"</span>,\n    <span class=\"hljs-attr\">child_process</span>: <span class=\"hljs-string\">\"empty\"</span>\n  }\n};\n</code></pre>\n<p>首先需要改的是入口文件，因为是多页面应用，需要多个入口文件来保证打包成不同的chunk。我们知道正常vue-cli创建的但页面应用，会打包成三个chunk，分别是vendor.js（第三方依赖），manifest.js（异步加载的实现），app.js（业务代码）。这里新增一个入口文件，打包时就会生成名为blog.js的chunk，含有前台展示页面的js业务代码。</p><p>这里新增使用的clean-webpack-plugin，是为了每次编译后，删除之前生成的js，css等静态资源，否则因为这些资源不重名，就会一直堆在你生成的目录下。</p><p>此外一些第三方依赖，vue,elementUI什么的，我使用了cdn引入，这样打包时这些依赖不会打进去，进而减小的vendor.js的体积。具体做法就是配置里的externals定义这些依赖，然后在生成html的模板里用script标签直接引入cdn里的js。</p><p>注意一下，如果你开发时想用vue-devtool，需要引入vue.js，如果不用就引入vue.min.js。</p><p>2.webpack.dev.conf.js的配置</p><p>先看下代码：</p><pre><code class=\"language-javaScript\"><span class=\"hljs-meta\">\"use strict\"</span>;\n<span class=\"hljs-keyword\">const</span> utils = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./utils\"</span>);\n<span class=\"hljs-keyword\">const</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"webpack\"</span>);\n<span class=\"hljs-keyword\">const</span> config = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../config\"</span>);\n<span class=\"hljs-keyword\">const</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"webpack-merge\"</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"path\"</span>);\n<span class=\"hljs-keyword\">const</span> baseWebpackConfig = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./webpack.base.conf\"</span>);\n<span class=\"hljs-keyword\">const</span> CopyWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"copy-webpack-plugin\"</span>);\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"html-webpack-plugin\"</span>);\n<span class=\"hljs-keyword\">const</span> FriendlyErrorsPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"friendly-errors-webpack-plugin\"</span>);\n<span class=\"hljs-keyword\">const</span> portfinder = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"portfinder\"</span>);\n\n<span class=\"hljs-keyword\">const</span> HOST = process.env.HOST;\n<span class=\"hljs-keyword\">const</span> PORT = process.env.PORT &amp;&amp; <span class=\"hljs-built_in\">Number</span>(process.env.PORT);\n<span class=\"hljs-keyword\">const</span> baseFileName = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../package.json\"</span>).name;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">dir</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> path.join(__dirname, <span class=\"hljs-string\">\"..\"</span>, dir);\n}\n<span class=\"hljs-keyword\">const</span> devWebpackConfig = merge(baseWebpackConfig, {\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: utils.styleLoaders({\n      <span class=\"hljs-attr\">sourceMap</span>: config.dev.cssSourceMap,\n      <span class=\"hljs-attr\">extract</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">usePostCSS</span>: <span class=\"hljs-literal\">true</span>\n    })\n  },\n  <span class=\"hljs-comment\">// cheap-module-eval-source-map is faster for development</span>\n  devtool: config.dev.devtool,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">path</span>: resolve(config.dev.assetsRoot),\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">\"static/\"</span> + baseFileName + <span class=\"hljs-string\">\"/js/[name]-[hash:5].js\"</span>,\n    <span class=\"hljs-attr\">chunkFilename</span>: <span class=\"hljs-string\">\"static/\"</span> + baseFileName + <span class=\"hljs-string\">\"/js/[name]-[id:5].js\"</span>\n  },\n\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin({\n      <span class=\"hljs-string\">\"process.env\"</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../config/dev.env\"</span>)\n    }),\n    <span class=\"hljs-comment\">// new webpack.HotModuleReplacementPlugin(),</span>\n    <span class=\"hljs-keyword\">new</span> webpack.NamedModulesPlugin(), <span class=\"hljs-comment\">// HMR shows correct file names in console on update.</span>\n    <span class=\"hljs-keyword\">new</span> webpack.NoEmitOnErrorsPlugin(),\n    <span class=\"hljs-comment\">// https://github.com/ampedandwired/html-webpack-plugin</span>\n    <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n      <span class=\"hljs-attr\">filename</span>: resolve(<span class=\"hljs-string\">`../view/blog/index_index.html`</span>),\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"./view/index.html\"</span>,\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"博客管理系统\"</span>,\n      <span class=\"hljs-attr\">favicon</span>: resolve(<span class=\"hljs-string\">\"favicon.ico\"</span>),\n      <span class=\"hljs-attr\">inject</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">chunks</span>: [<span class=\"hljs-string\">\"manifest\"</span>, <span class=\"hljs-string\">\"vendor\"</span>, <span class=\"hljs-string\">\"app\"</span>]\n    }),\n    <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n      <span class=\"hljs-attr\">filename</span>: resolve(<span class=\"hljs-string\">`../view/blog/blog_index.html`</span>),\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"./view/blog.html\"</span>,\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"博客展示\"</span>,\n      <span class=\"hljs-attr\">inject</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">chunks</span>: [<span class=\"hljs-string\">\"manifest\"</span>, <span class=\"hljs-string\">\"vendor\"</span>, <span class=\"hljs-string\">\"blog\"</span>]\n    }),\n    <span class=\"hljs-comment\">// copy custom static assets</span>\n    <span class=\"hljs-keyword\">new</span> CopyWebpackPlugin([\n      {\n        <span class=\"hljs-attr\">from</span>: path.resolve(__dirname, <span class=\"hljs-string\">\"../static\"</span>),\n        <span class=\"hljs-attr\">to</span>: config.dev.assetsSubDirectory,\n        <span class=\"hljs-attr\">ignore</span>: [<span class=\"hljs-string\">\".*\"</span>]\n      }\n    ])\n  ]\n});\n<span class=\"hljs-built_in\">module</span>.exports = devWebpackConfig;</code></pre>\n<p>这里我删掉了之前默认配置的devSever，以及module.exports直接导出devWebpackConfig。此外，因为打包生成目录的变化，我修改了output里面的path,filename,chunkFilename。使他们生成到self_blog根目录的www/static下面，这也是thinkJs静态资源的默认目录。需要注意下，filename指的是你的出口文件（app），以及通过codespliting生成的js（vendor,manifest）的文件名；chunkFilename定义的是一些懒加载组件打包后的js文件名。</p><p>下面需要添加的就是html-webpack-plugin，因为需要打包成两个html，所以使用两次这个插件。除了定义生成文件名（filename），html模板（template）等，还需要定义你这个html需要的chunk，这是跟单页面配置的一个区别。</p><p>除此之外，如果你想要开发环境打包时就分离出css，那么在使用utils.styleLoaders时，将extract置为true。因为这里的方法判断是开发环境才使用extract-text-plugin抽离css。</p><p>四.总结</p><p>这个项目还没有部署，所以就先不讲webpack.prod.config.js的东西了，我先改了一版，具体可以看github上的代码。本次项目主要目的是练习thinkJs，这里先把前期webpack配置方面的东西简单说下，下一篇将会仔细讲下thinkJs的使用方法和特性。项目会继续更新，不少东西还没做完呢。</p>', '2019-05-27 11:47:14', '2019-05-27 11:59:39', 7, '2019-05-27 11:59:39', 'Y', NULL);
INSERT INTO `sx_content` VALUES (36, 'Vue+thinkJs博客网站（二）之thinkJs的使用', 1, 'bb7aa9c3a626f565355b82b97757c92e', '/uploads/2019/05/b603f4d1a027cefdc050a2e173f4bfb2.jpg', 1, 99, 'post', '<p>这个个人博客网站最初制作的目的就是练习使用thinkJs，这一篇就主要讲一下thinkJs的一些特性和注意事项。涉及到了文件上传，thinkJs的插件机制，model层建立以及CURD的编写方式等。</p>', '这个个人博客网站最初制作的目的就是练习使用thinkJs，这一篇就主要讲一下thinkJs的一些特性和注意事项。涉及到了文件上传，thinkJs的插件机制，model层建立以及CURD的编写方式等。\n<!--more-->\n一.简介\n\n本项目github地址[在这里](https://github.com/sunxing102005/self_blog)。项目thinkJs端主要参考了知乎上大神Ischo的文章，链接[在这里](https://zhuanlan.zhihu.com/p/41880306)。\n二.thinkJs model层写法\n\n这里主要讲两个部分，一是表对应的js文件，二是CRUD写法。项目表结构比较简单，一共八个表，包含多对一，一对多，多对多关系。主要的几个表，都对应着model文件夹下的js文件，表关系也在这个js里维护。这里我们以model/content.js为例讲一哈：\n```javaScript\nmodule.exports = class extends think.Model {\n    // 模型关联\n    get relation() {\n        return {\n            category: {\n                type: think.Model.BELONG_TO,\n                model: \"meta\",\n                key: \"category_id\",\n                fKey: \"id\",\n                field: \"id,name,slug,description,count\"\n            },\n            tag: {\n                type: think.Model.MANY_TO_MANY,\n                model: \"meta\",\n                rModel: \"relationship\",\n                rfKey: \"meta_id\",\n                key: \"id\",\n                fKey: \"content_id\",\n                field: \"id,name,slug,description,count\"\n            },\n            comment: {\n                type: think.Model.HAS_MANY,\n                key: \"id\",\n                fKey: \"content_id\",\n                where: \"status=99\",\n                order: \"create_time desc\"\n            },\n            user: {\n                type: think.Model.BELONG_TO,\n                model: \"user\",\n                key: \"user_id\",\n                fKey: \"id\",\n                field: \"id,username,email,qq,github,weibo,zhihu\"\n            }\n        };\n    }\n\n    // 添加文章\n    async insert(data) {\n        const tags = data.tag;\n        data = this.parseContent(data);\n        delete data.tag;\n        const id = await this.add(data);\n        const relation = [];\n        tags.forEach(val => {\n            relation.push({\n                content_id: id,\n                meta_id: val\n            });\n        });\n        think.model(\"relationship\").addMany(relation);\n        // 更新文章数量\n        this.updateCount(data.category_id, tags);\n        return id;\n    }\n}\n```\n这里代码没有截全，完整代码看github。\n\n我们看到这个对象分为两部分，一个是get relation写的表映射关系。可以看到content表与meta表存在一对一关系（type: think.Model.BELONG_TO），这里key：category_id是content表里的字段，即外键，fkey：id是对应的meta表里的字段。查询时，会封装层user.category对象，对象属性就是field 定义的id,name,slug,description,count。content 与user也存在多对多关系（type: think.Model.MANY_TO_MANY），rfModel是多对多关系下，对应的关联关系模型名，默认值为二个模型名的组合，rfKey是多对多关系下，关系表对应的 key。\n\n另一个是Model里的方法，相当于自定义的model方法，比如这里定义的insert，就可以在controller里通过this.model(\'content\').insert()调用。\n\nthinkJS的CRUD操作，不是直接写sql，而是在sql基础上封装一层，通过调用model的方法来操作。think.Model 基类提供了丰富的方法进行 CRUD 操作，具体如下：\n```text\n查询数据\n模型提供了多种方法来查询数据，如:\n\nfind 查询单条数据\nselect 查询多条数据\ncount 查询总条数\ncountSelect 分页查询数据\nmax 查询字段的最大值\navg 查询字段的平均值\nmin 查询字段的最小值\nsum 对字段值进行求和\ngetField 查询指定字段的值\n同时模型支持通过下面的方法指定 SQL 语句中的特定条件，如：\n\nwhere 指定 SQL 语句中的 where 条件\nlimit / page 指定 SQL 语句中的 limit\nfield / fieldReverse 指定 SQL 语句中的 field\norder 指定 SQL 语句中的 order\ngroup 指定 SQL 语句中的 group\njoin 指定 SQL 语句中的 join\nunion 指定 SQL 语句中的 union\nhaving 指定 SQL 语句中的 having\ncache 设置查询缓存\n添加数据\n模型提供了下列的方法来添加数据：\n\nadd 添加单条数据\nthenAdd where 条件不存在时添加\naddMany 添加多条数据\nselectAdd 添加子查询的结果数据\n更新数据\n模型提供了下列的方法来更新数据：\n\nupdate 更新单条数据\nupdateMany 更新多条数据\nthenUpdate 条件式更新\nincrement 字段增加值\ndecrement 字段减少值\n删除数据\n模型提供了下列的方法来删除数据：\n\ndelete 删除数据\n手动执行 SQL 语句\n有时候模型包装的方法不能满足所有的情况，这时候需要手工指定 SQL 语句，可以通过下面的方法进行：\n\nquery 手写 SQL 语句查询\nexecute 手写 SQL 语句执行\n```\n比如我们要查询content表数据，在Controller里通过thin.model(\'content\').where(param).select()来查询。\n\nthinkJs的Model层与之前用过的java的数据层框架hibernate比较相似，都是基于面向对象的思想对sql进行封装，表与Model（实体类），通过model方法进行CRUD操作，特别省sql。\n\n三.插件机制的实现\n\n参考的博主实现的插件机制还是很好用的，这里我就拿了过来。插件机制可以说是自定义的钩子函数。首先在src新建service文件夹，新建js文件（以cache.js为例）\n```javaScript\nmodule.exports = class extends think.Service {\n    static registerHook() {\n        return {\n            content: [\"contentCreate\", \"contentUpdate\", \"contentDelete\"]\n        };\n    }\n    /**\n     * 更新内容缓存\n     * @param  {[type]} data [description]\n     * @return {[type]}      [description]\n     */\n    content(data) {\n        think.cache(\"recent_content\", null);\n    }\n};\n```\nregisterHook里content对应的数组表示钩子函数的调用名，具体调用的是下面的content方法。在controller里这么调用\n```javaScript\n await this.hook(\"contentUpdate\", data);\n```\n钩子函数的注册这里放到了worker进程里，thinkJs运行流程具体的可以看看官网 在这里。work.js代码如下：\n```javaScript\nthink.beforeStartServer(async () => {\n    const hooks = [];\n\n    for (const Service of Object.values(think.app.services)) {\n        const isHookService = think.isFunction(Service.registerHook);\n        if (!isHookService) {\n            continue;\n        }\n\n        const service = new Service();\n        const serviceHooks = Service.registerHook();\n        for (const hookFuncName in serviceHooks) {\n            if (!think.isFunction(service[hookFuncName])) {\n                continue;\n            }\n\n            let funcForHooks = serviceHooks[hookFuncName];\n            if (think.isString(funcForHooks)) {\n                funcForHooks = [funcForHooks];\n            }\n\n            if (!think.isArray(funcForHooks)) {\n                continue;\n            }\n\n            for (const hookName of funcForHooks) {\n                if (!hooks[hookName]) {\n                    hooks[hookName] = [];\n                }\n\n                hooks[hookName].push({ service, method: hookFuncName });\n            }\n        }\n    }\n    think.config(\"hooks\", hooks);\n});\n```\n这里将service里定义的method遍历取出，按一定格式保存并存放到数组，最后放到think.config里面，项目启动后这些过程就已经执行了。\n\nthink.Controller本身没有hook方法，这里需要在extend里面加上controller.js，代码如下：\n```javaScript\nmodule.exports = {\n    /**\n     * 执行hook\n     * @param  {[type]}    name [description]\n     * @param  {...[type]} args [description]\n     * @return {[type]}         [description]\n     */\n    async hook(name, ...args) {\n        const { hooks } = think.config();\n        const hookFuncs = hooks[name];\n        if (!think.isArray(hookFuncs)) {\n            return;\n        }\n        for (const { service, method } of hookFuncs) {\n            await service[method](...args);\n        }\n    }\n};\n\n```\n这样自定义钩子函数就实现了，一些通用的后置方法就可以直接共用一个了。\n\n四.路由\n\nthinkJs路由写在config/router.js里，具体代码如下：\n```javaScript\nmodule.exports = [\n  // RESTFUL\n  [/\\/api\\/(\\w+)(?:\\/(.*))?/, \'api/:1?id=:2\', \'rest\'],\n  [/\\/font\\/(\\w+)\\/(\\w+)/, \'fontend/:1/:2\'],\n  [\'/:category/:slug\', \'content/detail\'],\n  [\'/:category/:slug/comment\', \'content/comment\']\n];\n```\n里面的数组的第一个元素是匹配url的表达式，第二个元素是分配的资源，如果是采用RESTFUL规范定义的接口，第三个元素要写作\'rest\'。本项目的后台接口基本都是采用RESTFUL规范，具体路由的详细讲解可以看官网这里。\n\n五.部署\n\n项目线上部署采用PM2管理node进程，部署时把src,view,www,pm2.json,production.js放到服务器上。安装好pm2后运行\n```language\npm2 start pm2.json\n```\n注意pm2.json里需要修改cwd为服务器上你项目的目录。本项目前后端是一个服务，不存在所以没有用nginx代理。thinkJs部署相关可以看这里。\n\n\n\n\n\n\n', '<p>这个个人博客网站最初制作的目的就是练习使用thinkJs，这一篇就主要讲一下thinkJs的一些特性和注意事项。涉及到了文件上传，thinkJs的插件机制，model层建立以及CURD的编写方式等。</p><!--more-->\n<p>一.简介</p><p>本项目github地址<a href=https://github.com/sunxing102005/self_blog\n      title=https://github.com/sunxing102005/self_blog\n      target=\'_blank\'\n      }>在这里</a>。项目thinkJs端主要参考了知乎上大神Ischo的文章，链接<a href=https://zhuanlan.zhihu.com/p/41880306\n      title=https://zhuanlan.zhihu.com/p/41880306\n      target=\'_blank\'\n      }>在这里</a>。\n二.thinkJs model层写法</p><p>这里主要讲两个部分，一是表对应的js文件，二是CRUD写法。项目表结构比较简单，一共八个表，包含多对一，一对多，多对多关系。主要的几个表，都对应着model文件夹下的js文件，表关系也在这个js里维护。这里我们以model/content.js为例讲一哈：</p><pre><code class=\"language-javaScript\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> think.Model {\n    <span class=\"hljs-comment\">// 模型关联</span>\n    <span class=\"hljs-keyword\">get</span> relation() {\n        <span class=\"hljs-keyword\">return</span> {\n            category: {\n                <span class=\"hljs-keyword\">type</span>: think.Model.BELONG_TO,\n                model: <span class=\"hljs-string\">\"meta\"</span>,\n                key: <span class=\"hljs-string\">\"category_id\"</span>,\n                fKey: <span class=\"hljs-string\">\"id\"</span>,\n                field: <span class=\"hljs-string\">\"id,name,slug,description,count\"</span>\n            },\n            tag: {\n                <span class=\"hljs-keyword\">type</span>: think.Model.MANY_TO_MANY,\n                model: <span class=\"hljs-string\">\"meta\"</span>,\n                rModel: <span class=\"hljs-string\">\"relationship\"</span>,\n                rfKey: <span class=\"hljs-string\">\"meta_id\"</span>,\n                key: <span class=\"hljs-string\">\"id\"</span>,\n                fKey: <span class=\"hljs-string\">\"content_id\"</span>,\n                field: <span class=\"hljs-string\">\"id,name,slug,description,count\"</span>\n            },\n            comment: {\n                <span class=\"hljs-keyword\">type</span>: think.Model.HAS_MANY,\n                key: <span class=\"hljs-string\">\"id\"</span>,\n                fKey: <span class=\"hljs-string\">\"content_id\"</span>,\n                where: <span class=\"hljs-string\">\"status=99\"</span>,\n                order: <span class=\"hljs-string\">\"create_time desc\"</span>\n            },\n            user: {\n                <span class=\"hljs-keyword\">type</span>: think.Model.BELONG_TO,\n                model: <span class=\"hljs-string\">\"user\"</span>,\n                key: <span class=\"hljs-string\">\"user_id\"</span>,\n                fKey: <span class=\"hljs-string\">\"id\"</span>,\n                field: <span class=\"hljs-string\">\"id,username,email,qq,github,weibo,zhihu\"</span>\n            }\n        };\n    }\n\n    <span class=\"hljs-comment\">// 添加文章</span>\n    <span class=\"hljs-keyword\">async</span> insert(data) {\n        <span class=\"hljs-keyword\">const</span> tags = data.tag;\n        data = <span class=\"hljs-keyword\">this</span>.parseContent(data);\n        <span class=\"hljs-keyword\">delete</span> data.tag;\n        <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.add(data);\n        <span class=\"hljs-keyword\">const</span> relation = [];\n        tags.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n            relation.push({\n                content_id: id,\n                meta_id: val\n            });\n        });\n        think.model(<span class=\"hljs-string\">\"relationship\"</span>).addMany(relation);\n        <span class=\"hljs-comment\">// 更新文章数量</span>\n        <span class=\"hljs-keyword\">this</span>.updateCount(data.category_id, tags);\n        <span class=\"hljs-keyword\">return</span> id;\n    }\n}</code></pre>\n<p>这里代码没有截全，完整代码看github。</p><p>我们看到这个对象分为两部分，一个是get relation写的表映射关系。可以看到content表与meta表存在一对一关系（type: think.Model.BELONG_TO），这里key：category_id是content表里的字段，即外键，fkey：id是对应的meta表里的字段。查询时，会封装层user.category对象，对象属性就是field 定义的id,name,slug,description,count。content 与user也存在多对多关系（type: think.Model.MANY_TO_MANY），rfModel是多对多关系下，对应的关联关系模型名，默认值为二个模型名的组合，rfKey是多对多关系下，关系表对应的 key。</p><p>另一个是Model里的方法，相当于自定义的model方法，比如这里定义的insert，就可以在controller里通过this.model(&#39;content&#39;).insert()调用。</p><p>thinkJS的CRUD操作，不是直接写sql，而是在sql基础上封装一层，通过调用model的方法来操作。think.Model 基类提供了丰富的方法进行 CRUD 操作，具体如下：</p><pre><code class=\"language-text\">查询数据\n模型提供了多种方法来查询数据，如:\n\nfind 查询单条数据\nselect 查询多条数据\ncount 查询总条数\ncountSelect 分页查询数据\nmax 查询字段的最大值\navg 查询字段的平均值\nmin 查询字段的最小值\nsum 对字段值进行求和\ngetField 查询指定字段的值\n同时模型支持通过下面的方法指定 SQL 语句中的特定条件，如：\n\nwhere 指定 SQL 语句中的 where 条件\nlimit / page 指定 SQL 语句中的 limit\nfield / fieldReverse 指定 SQL 语句中的 field\norder 指定 SQL 语句中的 order\ngroup 指定 SQL 语句中的 group\njoin 指定 SQL 语句中的 join\nunion 指定 SQL 语句中的 union\nhaving 指定 SQL 语句中的 having\ncache 设置查询缓存\n添加数据\n模型提供了下列的方法来添加数据：\n\nadd 添加单条数据\nthenAdd where 条件不存在时添加\naddMany 添加多条数据\nselectAdd 添加子查询的结果数据\n更新数据\n模型提供了下列的方法来更新数据：\n\nupdate 更新单条数据\nupdateMany 更新多条数据\nthenUpdate 条件式更新\nincrement 字段增加值\ndecrement 字段减少值\n删除数据\n模型提供了下列的方法来删除数据：\n\n<span class=\"hljs-keyword\">delete</span> 删除数据\n手动执行 SQL 语句\n有时候模型包装的方法不能满足所有的情况，这时候需要手工指定 SQL 语句，可以通过下面的方法进行：\n\nquery 手写 SQL 语句查询\nexecute 手写 SQL 语句执行</code></pre>\n<p>比如我们要查询content表数据，在Controller里通过thin.model(&#39;content&#39;).where(param).select()来查询。</p><p>thinkJs的Model层与之前用过的java的数据层框架hibernate比较相似，都是基于面向对象的思想对sql进行封装，表与Model（实体类），通过model方法进行CRUD操作，特别省sql。</p><p>三.插件机制的实现</p><p>参考的博主实现的插件机制还是很好用的，这里我就拿了过来。插件机制可以说是自定义的钩子函数。首先在src新建service文件夹，新建js文件（以cache.js为例）</p><pre><code class=\"language-javaScript\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">think</span>.<span class=\"hljs-title\">Service</span> </span>{\n    <span class=\"hljs-keyword\">static</span> registerHook() {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">content</span>: [<span class=\"hljs-string\">\"contentCreate\"</span>, <span class=\"hljs-string\">\"contentUpdate\"</span>, <span class=\"hljs-string\">\"contentDelete\"</span>]\n        };\n    }\n    <span class=\"hljs-comment\">/**\n     * 更新内容缓存\n     * @param  {[type]} data [description]\n     * @return {[type]}      [description]\n     */</span>\n    content(data) {\n        think.cache(<span class=\"hljs-string\">\"recent_content\"</span>, <span class=\"hljs-literal\">null</span>);\n    }\n};</code></pre>\n<p>registerHook里content对应的数组表示钩子函数的调用名，具体调用的是下面的content方法。在controller里这么调用</p><pre><code class=\"language-javaScript\"> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.hook(<span class=\"hljs-string\">\"contentUpdate\"</span>, data);</code></pre>\n<p>钩子函数的注册这里放到了worker进程里，thinkJs运行流程具体的可以看看官网 在这里。work.js代码如下：</p><pre><code class=\"language-javaScript\">think.beforeStartServer(<span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">const</span> hooks = [];\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> Service <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.values(think.app.services)) {\n        <span class=\"hljs-keyword\">const</span> isHookService = think.isFunction(Service.registerHook);\n        <span class=\"hljs-keyword\">if</span> (!isHookService) {\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n\n        <span class=\"hljs-keyword\">const</span> service = <span class=\"hljs-keyword\">new</span> Service();\n        <span class=\"hljs-keyword\">const</span> serviceHooks = Service.registerHook();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> hookFuncName <span class=\"hljs-keyword\">in</span> serviceHooks) {\n            <span class=\"hljs-keyword\">if</span> (!think.isFunction(service[hookFuncName])) {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n\n            <span class=\"hljs-keyword\">let</span> funcForHooks = serviceHooks[hookFuncName];\n            <span class=\"hljs-keyword\">if</span> (think.isString(funcForHooks)) {\n                funcForHooks = [funcForHooks];\n            }\n\n            <span class=\"hljs-keyword\">if</span> (!think.isArray(funcForHooks)) {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> hookName <span class=\"hljs-keyword\">of</span> funcForHooks) {\n                <span class=\"hljs-keyword\">if</span> (!hooks[hookName]) {\n                    hooks[hookName] = [];\n                }\n\n                hooks[hookName].push({ service, <span class=\"hljs-attr\">method</span>: hookFuncName });\n            }\n        }\n    }\n    think.config(<span class=\"hljs-string\">\"hooks\"</span>, hooks);\n});</code></pre>\n<p>这里将service里定义的method遍历取出，按一定格式保存并存放到数组，最后放到think.config里面，项目启动后这些过程就已经执行了。</p><p>think.Controller本身没有hook方法，这里需要在extend里面加上controller.js，代码如下：</p><pre><code class=\"language-javaScript\"><span class=\"hljs-built_in\">module</span>.exports = {\n    <span class=\"hljs-comment\">/**\n     * 执行hook\n     * @param  {[type]}    name [description]\n     * @param  {...[type]} args [description]\n     * @return {[type]}         [description]\n     */</span>\n    <span class=\"hljs-keyword\">async</span> hook(name, ...args) {\n        <span class=\"hljs-keyword\">const</span> { hooks } = think.config();\n        <span class=\"hljs-keyword\">const</span> hookFuncs = hooks[name];\n        <span class=\"hljs-keyword\">if</span> (!think.isArray(hookFuncs)) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { service, method } <span class=\"hljs-keyword\">of</span> hookFuncs) {\n            <span class=\"hljs-keyword\">await</span> service[method](...args);\n        }\n    }\n};\n</code></pre>\n<p>这样自定义钩子函数就实现了，一些通用的后置方法就可以直接共用一个了。</p><p>四.路由</p><p>thinkJs路由写在config/router.js里，具体代码如下：</p><pre><code class=\"language-javaScript\"><span class=\"hljs-built_in\">module</span>.exports = [\n  <span class=\"hljs-comment\">// RESTFUL</span>\n  [<span class=\"hljs-regexp\">/\\/api\\/(\\w+)(?:\\/(.*))?/</span>, <span class=\"hljs-string\">\'api/:1?id=:2\'</span>, <span class=\"hljs-string\">\'rest\'</span>],\n  [<span class=\"hljs-regexp\">/\\/font\\/(\\w+)\\/(\\w+)/</span>, <span class=\"hljs-string\">\'fontend/:1/:2\'</span>],\n  [<span class=\"hljs-string\">\'/:category/:slug\'</span>, <span class=\"hljs-string\">\'content/detail\'</span>],\n  [<span class=\"hljs-string\">\'/:category/:slug/comment\'</span>, <span class=\"hljs-string\">\'content/comment\'</span>]\n];</code></pre>\n<p>里面的数组的第一个元素是匹配url的表达式，第二个元素是分配的资源，如果是采用RESTFUL规范定义的接口，第三个元素要写作&#39;rest&#39;。本项目的后台接口基本都是采用RESTFUL规范，具体路由的详细讲解可以看官网这里。</p><p>五.部署</p><p>项目线上部署采用PM2管理node进程，部署时把src,view,www,pm2.json,production.js放到服务器上。安装好pm2后运行</p><pre><code class=\"language-language\"><span class=\"hljs-selector-tag\">pm2</span> <span class=\"hljs-selector-tag\">start</span> <span class=\"hljs-selector-tag\">pm2</span><span class=\"hljs-selector-class\">.json</span></code></pre>\n<p>注意pm2.json里需要修改cwd为服务器上你项目的目录。本项目前后端是一个服务，不存在所以没有用nginx代理。thinkJs部署相关可以看这里。</p>', '2019-05-27 11:47:23', '2019-05-27 11:57:46', 0, '2019-05-27 11:57:46', 'Y', NULL);
COMMIT;

-- ----------------------------
-- Table structure for sx_meta
-- ----------------------------
DROP TABLE IF EXISTS `sx_meta`;
CREATE TABLE `sx_meta` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `user_id` int(10) NOT NULL,
  `name` varchar(50) NOT NULL,
  `slug` varchar(100) DEFAULT NULL,
  `description` varchar(200) DEFAULT NULL,
  `type` varchar(10) NOT NULL,
  `count` int(10) DEFAULT '0',
  `sort` int(10) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sx_meta
-- ----------------------------
BEGIN;
INSERT INTO `sx_meta` VALUES (1, 1, 'tech', 'tech', '', 'category', 7, 0);
INSERT INTO `sx_meta` VALUES (2, 1, 'life', 'life', '', 'category', 1, 0);
INSERT INTO `sx_meta` VALUES (6, 1, 'php', 'php', '', 'tag', 6, 0);
INSERT INTO `sx_meta` VALUES (7, 1, 'css', 'css', '', 'tag', 3, 0);
INSERT INTO `sx_meta` VALUES (9, 1, 'vue', 'vue', '', 'tag', 2, 0);
INSERT INTO `sx_meta` VALUES (10, 1, 'server', 'server', '', 'tag', 2, 0);
INSERT INTO `sx_meta` VALUES (12, 1, 'https', 'https', '', 'tag', 0, 0);
INSERT INTO `sx_meta` VALUES (13, 1, 'nodejs', 'nodejs', '', 'tag', 2, 0);
INSERT INTO `sx_meta` VALUES (17, 1, 'javascript', 'javascript', '', 'tag', 5, 0);
INSERT INTO `sx_meta` VALUES (18, 1, 'it', 'it', '', 'tag', -1, 0);
INSERT INTO `sx_meta` VALUES (19, 1, 'thinkphp5', 'thinkphp5', '', 'tag', 0, 0);
INSERT INTO `sx_meta` VALUES (20, 1, 'jointJS', 'jointJS', '', 'tag', 1, 0);
INSERT INTO `sx_meta` VALUES (21, 1, 'thinkJs', 'thinkJs', '', 'tag', 1, 0);
COMMIT;

-- ----------------------------
-- Table structure for sx_relationship
-- ----------------------------
DROP TABLE IF EXISTS `sx_relationship`;
CREATE TABLE `sx_relationship` (
  `content_id` int(10) NOT NULL,
  `meta_id` int(10) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sx_relationship
-- ----------------------------
BEGIN;
INSERT INTO `sx_relationship` VALUES (2, 6);
INSERT INTO `sx_relationship` VALUES (2, 7);
INSERT INTO `sx_relationship` VALUES (2, 6);
INSERT INTO `sx_relationship` VALUES (2, 7);
INSERT INTO `sx_relationship` VALUES (17, 6);
INSERT INTO `sx_relationship` VALUES (17, 19);
INSERT INTO `sx_relationship` VALUES (16, 6);
INSERT INTO `sx_relationship` VALUES (16, 19);
INSERT INTO `sx_relationship` VALUES (15, 13);
INSERT INTO `sx_relationship` VALUES (11, 14);
INSERT INTO `sx_relationship` VALUES (36, 7);
INSERT INTO `sx_relationship` VALUES (36, 6);
INSERT INTO `sx_relationship` VALUES (35, 21);
INSERT INTO `sx_relationship` VALUES (35, 17);
INSERT INTO `sx_relationship` VALUES (30, 20);
INSERT INTO `sx_relationship` VALUES (7, 6);
INSERT INTO `sx_relationship` VALUES (33, 9);
INSERT INTO `sx_relationship` VALUES (33, 17);
INSERT INTO `sx_relationship` VALUES (1, 17);
INSERT INTO `sx_relationship` VALUES (32, 9);
INSERT INTO `sx_relationship` VALUES (32, 17);
INSERT INTO `sx_relationship` VALUES (34, 13);
INSERT INTO `sx_relationship` VALUES (34, 17);
COMMIT;

-- ----------------------------
-- Table structure for sx_user
-- ----------------------------
DROP TABLE IF EXISTS `sx_user`;
CREATE TABLE `sx_user` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL,
  `email` varchar(100) DEFAULT NULL,
  `qq` varchar(15) DEFAULT NULL,
  `github` varchar(100) DEFAULT NULL,
  `zhihu` varchar(100) DEFAULT NULL,
  `weibo` varchar(100) DEFAULT NULL,
  `password` varchar(50) NOT NULL,
  `encrypt` varchar(10) NOT NULL,
  `last_login_time` int(10) DEFAULT NULL,
  `roles` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sx_user
-- ----------------------------
BEGIN;
INSERT INTO `sx_user` VALUES (1, 'admin', NULL, '', NULL, NULL, NULL, '24d8cee9ed793b9f818b6c4b67aae9aa', 'Mje5sowT7', 1559814431, 'admin');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
